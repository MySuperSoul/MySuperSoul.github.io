<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python-basic]]></title>
    <url>%2F2019%2F06%2F23%2Fpython-basic%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;最近马上要python考试了，anyway虽然是基础课，还是稍微复习一下，在这里记录一下可能会有的坑和平时作业里面的一些错题，以后依一些其他基本的需要注意的东西都可以写到里面来～ Slideschapter1 Unicode码：为每个字符设定了统一的并且是唯一的二进制编码，用来满足跨平台的需求。 \u表示Unicode码。 utf-8编码：每一个ASCII码都有一个对应的utf-8编码，正好与8位的ASCII编码是一样的。py程序默认是utf-8编码格式，并且是不定长的编码方式。 py是一种解释型的语言。 标识符：由字符，下划线，数字组成，但是注意的是不能以数字开头. my_test _123 chapter2 二进制，八进制，十六进制：0b(B)、0o(O)、0x(X) 浮点数运算存在误差：2.1-2.0==0.1 False. 并且浮点数的//运算输出也是浮点数。 复数：real+imag * j，其中real是实数部分，imag是虚数部分。 函数和方法：方法是依赖数据类型的另一种方法。 多行字符串，是用&#39;&#39;&#39;xxx&#39;&#39;&#39;来表示多行字符串。 python支持多条件比较，也即1&lt;3&lt;5 == 1&lt;3 and 3&lt;5, 1&lt;3&gt;2 == 1&lt;3 and 3&gt;2, 所以这两个都是True 3 and 5, 最后一个表达式的值作为整个表达式的值。 运算的优先级和方向：除掉**的方向是从右往左的，其他所有运算的方向都是从左往右的。 列表运算：加法[1, 2, 3] + [c, py], 乘法[1] * 3 -&gt; [1, 1, 1] int函数用法：int()-&gt;0, int(&quot;02&quot;), int(&quot; 35 &quot;), int(&quot;35&quot;, 8) 序列不等的赋值：i, *j = &quot;123&quot;, j -&gt; [&#39;2&#39;, &#39;3&#39;] 格式化：^, &lt;, &gt;分别代表的是居中、左、右对齐方式。科学计数法：.2e保留两位小数的科学计数法。{index_1:x.yf}{index_2:x.yf}格式化字符串。 chapter3 列表逆序：lst[::-1]。 列表的浅复制：b = a[:], 这样复制出来的就是两个不同的列表。 原始字符串：r&#39;hello\n&#39; -&gt; hello\n, 字符串不可修改, find(str, start_pos, end_pos) 字符串的format函数：{index:&lt;填充&gt;|^, &gt;, &lt;| &lt;宽度.精度&gt;&lt;格式&gt;} 列表方法：l.extend(x), l.pop(index)默认最后一个且会返回, l.remove(value), l.reverse(), l.sort(), l.insert(index, value)若index超则最后一个. 需要注意split函数： 123456sen = 'hello wor ld 's = sen.split()print(len(s)) -&gt; 3s = sen.split(' ')print(len(s)) -&gt; 10 随机函数库：random库 random.random() -&gt; [0.0, 1.0) random.uniform(a, b) -&gt; [a, b] random.randint(a, b) -&gt; 随机的一个整数 chapter4 Python map函数: map(function, iterable) 对指定的序列执行map操作，也即每个元素都执行function, x, y = map(int, input().split())执行的是内置函数int, 或者也可以是匿名函数map(lambda x : x**2, [1, 2, 3]). try-except使用格式： 1234567891011try: blockexcept Exception 1: block1except Exception 2: block2except: block3else: block4finally: block5 chapter5 set是一种容器，没有先后顺序，并且元素的值不重复, 需要注意的是集合的元素需要是不可变对象, 换句话说就是列表不能成为集合当中的元素. 空集合： 12empty = set()empty = &#123;&#125; #创建的是空字典 方法：add, remove, len, max, min, sum, issubset, issuperset, 需要牢记的是集合是无序的，所以每次print出来的结果是不确定的。 在集合当中的 == 判断的是两个set当中的元素是否是相同的，如果是相同的则输出的是True. &lt;, &lt;=, &gt;, &gt;=判断是子集，真子集，超集，真超集这些的。 集合运算|, &amp;, -, ^分别是并集、交集、差集、对称差，对称差指的是除了共同元素之外的元素，也就是a ^ b = (a | b) - (a &amp; b) 列表去重并且顺序不变两种方法： 123456789a = [1, 2, 6, 1, 3, 4, 2, 5]addr_to = list(set(a))addr_to.sort(key=a.index)a = [1, 2, 6, 1, 3, 4, 2, 5]addr_to = []for i in a: if not i in addr_to: addr_to.append(i) 字典的创建方式： 123fac = dict([(key1, value1), (key2, value2)])fac = dict(key1=value1, key2=value2) #这种方式需要使用标识符，并且键用的是str类型# -&gt; &#123;'key1':value1, 'key2':value2&#125; 字典的键必须要是不可变对象，可变对象比如列表，字典是不能作为字典的键的。 字典的方法：in, not in判断的是一个值是否存在字典的键当中。get(key, 默认值)这个函数可以在后面设置一个默认值作为不存在时候的返回，不加是None. chapter6 lambda表达式：g = lambda x, y, z : x + y + z -&gt; g(1, 2, 3) 位置参数: 就是普通的那种参数传递方式 关键字参数： 12345def dis(x1,y1,x2,y2): #求平面上两点距离 print("x1=&#123;&#125;,y1=&#123;&#125;,x2=&#123;&#125;,y2=&#123;&#125;".format(x1,y1,x2,y2)) return sqrt((x1-x2)**2+(y1-y2)**2)print(dis(x1=1,y2=5,y1=3,x2=4)) 位置参数与关键字参数一起使用：需要注意⚠️的是这种情况之下，位置参数需要先写，然后再使用关键字参数，否则会出错。 12345678910111213#correct usefrom math import sqrtdef dis(x1,y1,x2,y2): #求平 面上两点距离 print("x1=&#123;&#125;,y1=&#123;&#125;,x2=&#123;&#125;,y2=&#123;&#125;".format(x1,y1,x2,y2)) return sqrt((x1-x2)**2+(y1-y2)**2)print(dis(1,3,y2=5,x2=4))#wrong casefrom math import sqrtdef dis(x1,y1,x2,y2): #求平面上两点距离 print("x1=&#123;&#125;,y1=&#123;&#125;,x2=&#123;&#125;,y2=&#123;&#125;".format(x1,y1,x2,y2)) return sqrt((x1-x2)**2+(y1-y2)**2)print(dis(1,y1=3,4,5)) 默认值参数：这里就是需要注意的是，默认值参数在函数对象被创建的时候同时被创建，相当于如果默认值有一个list的时候，有一个静态的static的list一直存在： 12345def init(arg, result=[]): result.append(arg)print(result)init('a') #['a']init('b') #['a', 'b'] 不定长数目参数：使用*将可变的参数变为元组存放，具体的使用🌰： 12345def countnum(a,*b): #计算参数个数 print(b) #(7, 9) print(len(b)+1) # 3countnum(3,7,9)countnum(5,8,1,6,89) *或者是**作用在函数的形参上代表的分别是用元组和字典来接收参数。*或者是**作用在实参上代表的是解包： 1234567lst = [1, 2, 3]print(*lst) # 1 2 3def countnum(a,**d): #计算参数个数 print(d) print(len(d)+1)countnum(3,x1=9,x2=1,x3=6,x4=89) 命名空间：全局变量和局部变量不一样，在局部区域里面可以使用全局变量，但是这个时候不能在局部函数内部再定义同名变量，否则出错❌。但是一旦定义了同名的变量，使用都是用的局部变量来使用。要使用和修改全局变量，请使用global关键字来完成。 内置函数zip用来打包📦两个可迭代的序列 123456789101112131415161718192021222324252627a = [1, 2, 3]b = [4, 5, 6]print(list(zip(a, b)))# 字典的键值对互换dic = &#123;1:1, 2:2, '1':500&#125;print(dict(zip(dic.values(), dic.keys())))# &#123;1: 1, 2: 2, 500: '1'&#125;# eval 计算表达式的值a = 3; b = 7print(eval('a * 3 + b * 5'))# exec 执行python语句exec('print("hello world")')'''all, any 接受的是可迭代的序列all表示全部是True，才返回Trueany表示只要有一个True，即结果最后返回的是True'''all([[], False, 0]) # Falseall([1, True, [1]]) # Trueany([[], False, 0]) # False# __main__的作用域就是全局域 命令行参数格式：sys.argv[0]文件名，sys.argv[1]…都是参数。 chapter7 文件打开：open(filename, mode) 读写函数： read: 将文件所有内容读取 readlines: 按行读取内容，但是列表当中的每一项最后都有一个\n, readline也是一样的会有一个\n在读取的字符串最后。 多条件排序： 12ans=sorted(counts.items(), key=lambda x:(-x[1], x[0]))# 按照value降序，然后再按照key升序排列 chapter8 一切内容皆是对象，函数和类也是对象。 类主要指的是类型，对象是比较具体的一些值。lst = [1, 2, 3], 其中lst是类list的class，也就是list类型的对象 类有自己的名字空间，同时每个对象也有自己的名字空间。 构造方法：def __init__(self, …) 构造方法，当对象被构造的时候被自动调用，可以声明类所产生的对象属性，并可为其赋初始值，最重要的是这个函数是不能有返回值的。-&gt; 创建对象的时候调用的是object本身的__init__方法。 self参数：必须为第一个形参，代表的是将来要创建的对象本身。在类的方法当中访问数据成员的时候，需要使用self.parameter进行调用。在外部通过对象调用实例方法的时候不需要传递self参数，如果在外部通过类来调用实例方法的时候，可以显式的把对象传到self里面。 python社团规定： _xxx 内部名，不应该在外部使用 __xxx py解释器会自动换名为_class__xxx，所以对象是直接访问不到这个变量的.但是需要注意的是，可以使用object._class__xxx访问到该变量，所以并不是绝对意义上的私有变量。 __xxx__系统定义的特殊成员，一般不使用这种标识符。 类变量和实例变量都是可以动态增加对应的变量的. 继承的类如果重写了__init__, 如果要初始化父类需要显式的super().__init__调用父类的初始化函数。 python多态，一般是通过重写__add__, __len__, __sub__之类的函数来自定义自己的基本运算。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>basis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Old Books Trading Website]]></title>
    <url>%2F2019%2F06%2F22%2FWebsite%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;陆陆续续写了大概两周时间的旧书交易网站终于快写完啦！！BS课程的课程项目设计，真是心力交瘁。刚好新搞了一个博客试试水，就在这里记录一些开发过程当中的感想和碰到的很多很多坑吧orz，不过还是学到很多东西的吖！ 后端框架&nbsp;&nbsp;&nbsp;&nbsp;后端框架选用的是Django框架开发的，为什么选Python作为后端的语言呢，一方面是这学期刚好也有在上python课程，另一方面python真的很友好啊，不过以后也要尝试用java spring做点小项目。 Django路由&nbsp;&nbsp;&nbsp;&nbsp;Django框架遵循的是MVC的思想进行开发的框架。urls.py当中是网站路由的配置，一般项目的路由当中是划定不同app下的起始路由，然后在不同的app下再定义各自的url，使得整个项目的路由管理比较独立，比如在我项目当中的总路由配置(BookTradeWeb/urls.py): 123456789urlpatterns = [ path('admin/', admin.site.urls), url(r'^password-reset/', include('password_reset.urls')), url(r'^auth/', include('useraction.urls')), url(r'^books/', include('books.urls')), url(r'^chatting/', include('chatting.urls')), url(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;'document_root': settings.MEDIA_ROOT&#125;), url(r'^$', TemplateView.as_view(template_name="login.html")),] &nbsp;&nbsp;&nbsp;&nbsp;然后在每个单独的app里面可以自定义自己的路由了，以我其中一个app(useraction)下的urls.py为🌰，不过需要记住的是通过python manage.py startapp 创建之后的urls.py是需要自己创建的。在不同的app里面可以定义自己的app_name，在后面写模板语言的时候非常爽的，后面在前端那里再详细写： 1234567app_name = 'useraction'urlpatterns = [ url(r'^login/$', views.UserLoginView.as_view(), name='login'), url(r'^register/$', views.UserRegisterView.as_view(), name='register'), url(r'^logout/$', views.UserLogoutView.as_view(), name='logout'),] Django Views&nbsp;&nbsp;&nbsp;&nbsp;Django views可以说是很强大了，在MVC架构当中它可以充当view和controller两部分的角色。现在很流行使用restful的方式开发网站。也即后端只提供数据，用json或者protobuf或者其他的数据组织形式来传输数据，而前端向后端发送请求来请求数据或者处理逻辑，实现前后端分离的开发。&nbsp;&nbsp;&nbsp;&nbsp;Django views因为有很多Django自己的加持，使得这两种模式都支持，比如JsonResponse返回json格式的数据，或者通过render(request, index.html, data)的方式直接返回网页，并且能用非常爽的模板语言，简直人见人爱啊有木有！&nbsp;&nbsp;&nbsp;&nbsp;这里我选择的是用的class-based view的方式来写views.py的，在BookTradeWeb/utils.py当中定义了BaseView，这个类继承了Django当中内置的view，后面我们自己的view只需要继承BaseView即可，我们看看BaseView里面定义了些啥： 123456789101112131415161718192021222324252627282930313233class BaseView(View): def dispatch(self, request, *args, **kwargs): self.request = request request.data = &#123;&#125; if request.method == 'GET': request.data = request.GET.dict() elif request.content_type == 'application/json': request.data = request.body.replace(b"'", b'"') request.data = json.loads(request.data) elif request.content_type == 'multipart/form-data': request.data = request.POST.dict() if not request.FILES == None: request.data['file'] = request.FILES['file'] elif request.content_type == 'application/x-www-form-urlencoded': request.data = request.POST.dict() return self.do_dispatch(request, *args, **kwargs) def do_dispatch(self, *args, **kwargs): handler = getattr(self, self.request.method.lower(), None) if not callable(handler): return JsonResponse(make_errors(f"http method &#123;self.request.method.lower()&#125; not allowed ")) else: try: data = handler(*args, **kwargs) if data == None: return JsonResponse(make_success('success')) elif self.request.method == 'GET' or not isinstance(data, dict): return data else: return JsonResponse(&#123;'data': data, 'code': 0&#125;) except Exception as e: traceback.print_exc() return JsonResponse(make_errors(str(e))) &nbsp;&nbsp;&nbsp;&nbsp;这样定义BaseView有什么好处呢，首先在BaseView里面重写了View当中的dispatch方法，每当有一个请求到达对应路由那里的时候，都会调用dispatch方法。在dispatch当中我们将数据统一都放到request.data里面，后面的views当中无论是POST还是GET都可以在request.data里面拿到数据。&nbsp;&nbsp;&nbsp;&nbsp;其次在do_dispatch当中会去自定义view里面找对应request method的处理方法，也就是说，我们的自定义view里面只需要去写对应的函数，比如说def get(self, request) 处理get请求，def post(self, request)来处理对应的post请求，是不是很方便呢！在自定义view写完之后，只需要在urls.py里面去注册一下就好了，下面举一个🌰： 12345678910111213141516class UserLoginView(BaseView): def post(self, request): user = authenticate(username = request.data.get('username'), password = request.data.get('password')) if user and user.is_active: login(request, user) return user.to_dict() elif not user: raise Exception('用户名或密码错误！') def get(self, request): return render(request, 'login.html')useraction/urls.pyurl(r'^login/$', views.UserLoginView.as_view(), name='login') Django models&nbsp;&nbsp;&nbsp;&nbsp;Django提供了一套非常完备的ORM，以至于我真的一行SQL语句都没写啊😂。models也就是数据库里面的表，通过类定义的方式来定义每一张表当中的数据项、属性、外键约束等等。一般定义好models之后只需要执行python manage.py makemigrations &amp;&amp; python manage.py migrate将models迁移到数据库当中。Django项目初始默认使用的数据库是sqlite，我这里将它改成了MySQL，具体就是修改setting.py里面的配置就好了。&nbsp;&nbsp;&nbsp;&nbsp;ORM的语法网上教程或者是Django官网教程都有很多的。主要就是内部用的一个QuerySet类来代表返回结果，还有很多奇奇怪怪的用法这里就不再赘述。 Django setting&nbsp;&nbsp;&nbsp;&nbsp;Django 通过在项目目录下的setting.py下面进行整个项目的配置，大概讲解一下这些配置是干啥的，就讲一些主要的，其他的都是很容易Google到的： ALLOWED_HOSTS: 允许那些host访问，如果需要允许所有一般设置为[‘*’, ] INSTALLED_APPS: 这个配置是比较重要的一部分，用来注册项目里面的app，如果你新建的app没有在这里注册的话，项目是找不到你的app里面的方法的，所以我们每次新建都需要在这里进行注册之后才能正常的工作哦😯 Middleware: 这里是项目中使用的中间件的配置，比如Django内置的用户认证中间价，防跨站攻击的csrftoken中间价等等，如果使用其他的开源中间价都需要在这里进行注册。 TEMPLATES: 这里主要是存放的静态文件的意思，基本不用去改，Django会去项目所有的templates文件夹下面找对应的模板文件。 DATABASES: 顾名思义就是数据库的配置了，你想用哪个数据改改这个就好了。 1234567STATIC_URL = '/static/' STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'BookTradeWeb/static') ] MEDIA_URL = '/media/' MEDIA_ROOT = os.path.join(BASE_DIR, 'media/') 这两个是静态文件和资源文件的存放位置，Django会去static和media文件夹里面自动寻找。 前端模板&nbsp;&nbsp;&nbsp;&nbsp;前端还是主要用的传统的html+js+css的格式，然后通过ajax向后端发起请求，没能用现在很流行的React或者是Vue有点可惜，只能感慨前端太难了！！.不过Django自己的模板语言用起来还是可以的，不过我感觉这个项目调前端的时间是最主要的啊orz. 静态文件加载&nbsp;&nbsp;&nbsp;&nbsp;之前我们在setting里面配置好了static文件目录之后，在模板里面我们可以这样引入，在最开头通过 12&#123;% load staticfiles %&#125; 加载静态文件&#123;% static 'images/favicon.png' %&#125; 引入对应文件 &nbsp;&nbsp;&nbsp;&nbsp;注意Django会搜索所有的static文件夹下的文件，所以一般使用app名称作为前缀来进行区分。 前端路由&nbsp;&nbsp;&nbsp;&nbsp;在之前我们提到每个urls.py里面我们可以添加一个app_name字段，并且每个url_pattern里面都可以带上一个name字段，然后在前端就可以直接用模板语言当中的url &#39;app_name:name&#39;来获取后端定义好的路由，这样就算你后端改了路由之后，前端根本不用管啊是不是～ 123456useraction/urls.pyapp_name = 'useraction'url(r'^register/$', views.UserRegisterView.as_view(),name='register')template:&#123;% url 'useraction:register' %&#125; 前端数据渲染&nbsp;&nbsp;&nbsp;&nbsp;有两种方式，一种是通过ajax向后端请求，然后用js来进行数据渲染，还有一种是通过模板语言，在render方法的时候将数据传递到模板里面，然后使用模板语言渲染，常用的有： 12345678910111213&#123;&#123; data &#125;&#125; 取出传递进来数据当中的data字段&#123;% if ... %&#125;&#123;% else %&#125;&#123;% endif %&#125; 模板语言当中的if语句&#123;% for book in books %&#125;&#123;&#123; book.data &#125;&#125;&#123;% endfor %&#125; 模板语言当中的for语句&#123;&#123; book.time|data:"Y-M-d" &#125;&#125; 模板语言当中的filter过滤器&#123;&#123; request.user &#125;&#125; 模板当中获取当前请求的user &nbsp;&nbsp;&nbsp;&nbsp;还有很多其他的用法大家自己网上找找也能找到。这里主要将还可以自定义自己的filter，一个很直观的需求就是我像模板里面传进了一个字典，窝怎么根据键来找值呢，Django提供了自定义filter的功能，在app目录下面新建一个templatetags文件夹，首先新建一个__init__.py为空不要紧，但是一定要有。然后建一个自定义的filter文件，这里我是books_filter.py，通过@register.filter标注为一个自定义的filter，然后就写你想要的filter逻辑即可： 123456789101112from django.template.defaulttags import registerfrom BookTradeWeb.utils import Categoryfrom books.models import Book@register.filterdef GetDictValue(dictionary, key): assert isinstance(dictionary, dict) return dictionary.get(key)模板中使用：首先最上方引入你的filter &#123;% load books_filter %&#125;然后用法：&#123;&#123; book_dict|GetDictValue:key &#125;&#125; Websocket&nbsp;&nbsp;&nbsp;&nbsp;由于Django本身是不支持websocket的，但是这次要求要集成一个消息系统，所以想到的是websocket这个全双工的协议。Google了一下，可以通过django-channels第三方的package来实现✅，所以直接pip安装就好。channels是用的redis做消息缓存，所以还要pip install channels-redis，这些需要的依赖一般都是写在requirements.txt当中。如果不想在本机安装redis可以通过docker来开启服务，具体就是开一个docker container就好，docker run -d -p 6379:6379 redis:latest, 搞定。&nbsp;&nbsp;&nbsp;&nbsp;在setting里面注册channels这个app，然后添加如下的设置: 123456789ASGI_APPLICATION = "BookTradeWeb.routing.application"CHANNEL_LAYERS = &#123; 'default': &#123; 'BACKEND': 'channels_redis.core.RedisChannelLayer', 'CONFIG': &#123; "hosts": [(CONFIGS['REDIS_HOST'], CONFIGS['REDIS_PORT'])], &#125;, &#125;,&#125; &nbsp;&nbsp;&nbsp;&nbsp;asgi配置主要是用来处理websocket请求的，类似ws://这样的请求Django自己的服务器是处理不了的，所以这里用asgi配置，需要在app目录下面新建一个routing.py用来处理websocket路由。 1234567891011121314151617项目目录(BookTradeWeb/routing.py)application = ProtocolTypeRouter(&#123; # (http-&gt;django views is added by default) 'websocket' : AuthMiddlewareStack( URLRouter( chatting.routing.websocket_urlpatterns ) ),&#125;)app目录下(chatting/routing.py)from django.conf.urls import urlfrom . import consumerswebsocket_urlpatterns = [ url(r'^ws/chat/(?P&lt;room_name&gt;[^/]+)/$', consumers.ChatConsumer),] &nbsp;&nbsp;&nbsp;&nbsp;经过这样一通配置，开启python manage.py runserver，看到ASGI/Channels就配置成功了。 Consumer&nbsp;&nbsp;&nbsp;&nbsp;在channels当中处理websocket请求的东西叫做consumer，和上面我们提到的view一样，consumer也是可以自定义的，可以继承自AsyncWebsocketConsumer来实现自己的consumer。主要是几个functions重写一下就好了，connect, disconnect, receive，都是字面意思了就不解释了。每一个websocket连接都会给到一个channel给连接的用户。每一个channel都有一个独有的channel_name, 通过self.channel_name即可获取。 Group&nbsp;&nbsp;&nbsp;&nbsp;Group组的概念，聊天室必备啊。group以group name来进行区分，不同的channel都可以加入到group里面，group当中提供了group_send来进行广播📢，也就是聊天室的那种效果了。 channel_layer&nbsp;&nbsp;&nbsp;&nbsp;Django-channels当中提供了get_channel_layer()方法来向指定的channel发送消息，具体使用如下，也就是我们要的点对点聊天的功能了： 123456789101112131415161718from channels.generic.websocket import AsyncWebsocketConsumerfrom channels.layers import get_channel_layerfrom channels.db import database_sync_to_asyncfrom collections import defaultdictfrom useraction.models import Userfrom chatting.models import ChattingMessageimport jsonchannel_layer = get_channel_layer()await channel_layer.send( channel_name, &#123; "type" : "chat.message", "message" : message, "send_side" : send_side, "option" : "chat" &#125;) Database&nbsp;&nbsp;&nbsp;&nbsp;在channels当中，我们的处理方式都是异步的，比如函数定义都是async, 函数使用都是await, 那对数据库操作一般Django都是同步的操作，这样在channels里面运行是没有任何作用的，所以这个时候我们使用注解让数据库的操作变成异步的@database_sync_to_async, 然后对数据库的操作写在一个函数里面，使用🌰： 12345678910from channels.db import database_sync_to_async@database_sync_to_asyncdef CreateNewMessage(self, send_side, recv_side, message): mess = ChattingMessage.objects.create( send_side_id=int(send_side), recv_side_id=int(recv_side), message=message ) mess.save() 部署方法&nbsp;&nbsp;&nbsp;&nbsp;这个项目我使用的是docker进行部署，总共是3个container，其中包括mysql, redis, website这三个container，服务端口列表为: port service 6379 redis 3000 mysql 8000 website docker-compose&nbsp;&nbsp;&nbsp;&nbsp; 我用的是docker-compose来管理docker container之间的连接关系，重要的配置文件窝都写在项目目录下的config.json里面，docker-compose方便进行container之间的连接，并且自动建立不同container之间的network，能让多个container进行互相访问，非常的方便，用的时候是写docker-compose.yml： 1234567891011121314151617181920212223242526version: '3'services: db: image: mysql:latest command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8 --collation-server=utf8_general_ci ports: - "3000:3306" environment: MYSQL_DATABASE: 'booktrade' MYSQL_ROOT_PASSWORD: 'your-password' redis: image: redis:latest restart: always expose: - "6379" web: build: . command: ./scripts/start_server.sh entrypoint: ./scripts/docker_entry.sh db 3306 restart: always ports: - "8000:8000" depends_on: - db - redis &nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，这里有一个大坑，就是web container在开启的时候，是和其他服务一起开启的，所以在mysql container还没初始化好的时候，web container就开始尝试写数据到数据库里面去了，当然，这样服务器of course crash了，所以在entrypoint这里加了一个脚本去检查，如果没有初始化好就sleep去等，初始化完毕之后再去连接数据库： 12345678910111213141516171819scripts/docker_entry.sh#!/bin/shpostgres_host=$1postgres_port=$2shift 2cmd="$@"# wait for the postgres docker to be runningwhile ! nc $postgres_host $postgres_port; do &gt;&amp;2 echo "MySQL is unavailable - sleeping" sleep 1done&gt;&amp;2 echo "MySQL is up - executing command"# run the commandexec $cmd &nbsp;&nbsp;&nbsp;&nbsp;web项目的Dockerfile主要就是初始化环境，安装一些package的依赖： 12345678910111213FROM python:3.6MAINTAINER huangyifei &lt;huangyifei0910@gmail.com&gt;RUN mkdir /codeADD . /codeWORKDIR /codeRUN wget -qO- git.io/superupdate.sh | bashRUN apt-get -y install jq netcat-openbsdRUN jq '.DB_HOST = "db"' config.json &gt;&gt; tmp.json &amp;&amp; mv tmp.json config.jsonRUN jq '.REDIS_HOST = "redis"' config.json &gt;&gt; tmp.json &amp;&amp; mv tmp.json config.jsonRUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt &nbsp;&nbsp;&nbsp;&nbsp;在所有这些做完之后，使用docker-compose build构建当前项目，docker-compose up -d进行container的链接和后台运行，因为mysql container的初始化时间比较长，所以开启之后需要等待20-30s然后就可以愉快的访问啦(localhost:8000)～ 窝是将这个步骤写在./scripts/start_docker.sh里面，./scripts/stop_docker是停止所有的服务，并且移除相对应的container，即插即用，是不是很方便！！ 项目总结&nbsp;&nbsp;&nbsp;&nbsp;第一次用Django做后端和docker-compose来部署项目还是踩了不少的坑orz，不过Django强大的特性和很多第三方的package加持，做后端的很多功能也是挺方便的。docker主要是这学期开始接触的，我觉得这东西势必会统治虚拟化啊，即插即用，生态也非常的好，用来部署项目省了很多乱七八糟的配置的问题。后面也会考虑去学一学前端的框架，React or Vue anyway, 还有很多需要学习的，任重而道远啊！Make Progress Everyday！ 项目地址：BookTradeWeb 使用方法：参考README.md当中的部署方法 部署好的网站：website Author: huangyifei Email: huangyifei0910@gmail.com]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>docker-compose</tag>
        <tag>websocket</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
