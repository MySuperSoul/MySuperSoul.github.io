<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Beauty-of-Mathematics</title>
    <url>/2019/07/01/Beauty-of-Mathematics/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;最近很有幸能够拜读<code>吴军</code>博士的《数学之美》这本书，在这里记录一些自己在阅读当中的感受和体会，顺便也做一点摘抄啥的，日后能够回味当时看这本书的感受啦！</p>
<a id="more"></a>
<h4 id="1-文字和语言vs数字和信息"><a href="#1-文字和语言vs数字和信息" class="headerlink" title="1. 文字和语言vs数字和信息"></a>1. 文字和语言vs数字和信息</h4><ul>
<li>通信模式：信息源 -&gt; (怪叫声，编码) -&gt; 信息（信道传输）-&gt;（听到的声音，解码）-&gt; 信息(接收者)，古人通过声音来相互传递信息，和现在的信息传输的模式无差。</li>
<li><p>罗塞塔石碑：罗塞塔石碑上记录了从古埃及至今的历史，破译过程归功于在石碑之上有三种不同语言版本的信息。所以作者通过此得到两个有用的结论：</p>
<ul>
<li><code>信息冗余</code>是信息安全的保障。只要有一份内容被完整的保留下来，那么信息就不会丢失，这对于现代的信道编码有一定的指导意义。</li>
<li><code>语言的数据，又被成为语料</code>。双语或者是多语的对照语料，对于machine translation领域的研究是一个基础性的工程。</li>
</ul>
</li>
<li><p>接下来进入到数字的部分，在最开始的时候，数字只是单纯的用来进行计数，而并没有更加高层的抽象概念表达。例如中国🇨🇳人对于不同位数数字的编码是<code>个十百千万</code>，这也就是最最朴素的<code>编码方式</code>，而<code>解码方式</code>就是我们很熟悉的乘法，例如<code>20000 = 2x10x1000</code>. </p>
</li>
<li>从象形文字到拼音文字的转变是一个飞跃，说明人类在描述物体的方式上加入了<code>抽象</code>的层次。同时我们也能在日常的文字当中找到<code>信息论</code>中<code>最短编码原理</code>的影子。比如说常用的文字一般笔画较少，而生僻字大多笔画比较多。这种<code>文字设计方法</code>本质上就是一种<code>编码方式</code>。</li>
<li>古犹太人抄写 <strong>《圣经》</strong> 的小故事：在抄写的时候难免会存在抄写错误的情况，那么聪明的古犹太人发明了一种和现代通信当中<code>校验位</code>思想很类似的一种方法。把每一个希伯来字母对应一个数字，然后每行文字加起来就能得到一个特殊的数字，同时对于每一列的文字进行同样的操作。这样对于每一行每一列都有一个唯一的<code>校验位</code>，当抄写完一页的时候，会去和原文逐一对比，如果一致就说明抄写无误了。</li>
<li>这章当中还提到了一个语言学研究方法的问题，<code>到底是语言对，还是语法对</code>.前者坚持从真实的语句文本，从语料出发，后者则是坚持从语言的规则出发入手，当然现在的NLP领域的成就宣告是前者的获胜。</li>
</ul>
<h4 id="2-自然语言处理-—-从规则到统计"><a href="#2-自然语言处理-—-从规则到统计" class="headerlink" title="2. 自然语言处理 — 从规则到统计"></a>2. 自然语言处理 — 从规则到统计</h4><ul>
<li>人类的语言本质上是一种编解码的过程，人想要将自己的所想表达出来，通过语言进行<code>编码</code>，然后其他人需要理解你的意思的话，需要对语言进行<code>解码</code>，从而获取到想要表达的意思。</li>
<li>最早提出<code>机器智能</code>思想的是<code>阿兰图灵</code>在1950年的一篇paper当中提出的，也即非常著名的<code>图灵测试</code>。</li>
<li>当前的NLP领域的成就全都靠的数学，更准确的说是靠的<code>统计</code>的支持。</li>
<li>NLP研究从最早的基于语法规则的方法转变到了基于数学统计的方法。同时NLP研究也从单纯的<code>句法分析和语义理解</code>，变成了非常贴近实际应用的MT、语音识别、数据挖掘、知识获取等等实际领域。</li>
</ul>
<h4 id="3-统计语言模型"><a href="#3-统计语言模型" class="headerlink" title="3. 统计语言模型"></a>3. 统计语言模型</h4><ul>
<li>自然语言逐渐演变为<code>上下文相关的信息表达和传递方式</code>，一个基本问题就是为这种上下文相关的特性建立<code>统计数学模型</code>。也就是NLP当中非常重要的<a href="https://zhuanlan.zhihu.com/p/27201427" target="_blank" rel="noopener">统计语言模型</a></li>
<li><strong>马尔可夫假设</strong>：假设每个词出现的概率$\omega_i$只与前一个词$\omega_{i-1}$是相关的，也就是最后一个句子出现的概率表示为$p(S) = p(\omega_1) * p(\omega_2|\omega_1) * p(\omega_3|\omega_2) * … * p(\omega_n|\omega_{n-1})$. 这种模型又叫做<code>二元模型</code>，如果是之前的以前n个模型出现的概率来估计下一个词出现的概率，则这种模型叫做<code>N元模型</code>.<br>转换成这种形式之后，就能很方便的通过<code>语料</code>来解决统计的问题，根据<code>大数定理</code>，最后的频率估计就基本近似于实际的概率估计，也即：<script type="math/tex; mode=display">
p(\omega_n|\omega_{n-1}) = \frac{p(\omega_n, \omega_{n-1})}{p(\omega_{n-1})} \tag{1}</script></li>
</ul>
<h4 id="4-分词"><a href="#4-分词" class="headerlink" title="4. 分词"></a>4. 分词</h4>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>cs224n-papers</title>
    <url>/2020/07/28/cs224n-papers/</url>
    <content><![CDATA[<p>This post will mainly contain the paper notes about the papers in cs224n course. Usually some typical papers in nlp field.<br><a id="more"></a></p>
<hr>
<h1 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a><a href="https://arxiv.org/abs/1301.3781" target="_blank" rel="noopener">word2vec</a></h1><h2 id="Model-Architectures"><a href="#Model-Architectures" class="headerlink" title="Model Architectures"></a>Model Architectures</h2><p>Mainly two types: NNLM and RNNLM.</p>
<h2 id="New-log-linear-models"><a href="#New-log-linear-models" class="headerlink" title="New log-linear models"></a>New log-linear models</h2><h3 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h3><p>CBOW(continuos bag of words) model, the main idea is using context to predict the center word. Input is the context words, with one projection hidden layer, and output center word. The architecture is shown:</p>
<div align="center">
<img src="/2020/07/28/cs224n-papers/1-1.png" style="width: 40%">
</div>

<h3 id="Skip-gram-model"><a href="#Skip-gram-model" class="headerlink" title="Skip-gram model"></a>Skip-gram model</h3><p>Skip-gram model is different from CBOW, in skip-gram model, it tries to maximize classification of a word based on another word in the same sentence. So input is the center word, with one projection layer, and output is the probabilities of other context words. The architecture is shown:</p>
<div align="center">
<img src="/2020/07/28/cs224n-papers/1-2.png" style="width: 40%">
</div>

<hr>
<h1 id="Distributed-Representations-of-Words-and-Phrases-and-their-Compositionality"><a href="#Distributed-Representations-of-Words-and-Phrases-and-their-Compositionality" class="headerlink" title="Distributed Representations of Words and Phrases and their Compositionality"></a><a href="https://arxiv.org/abs/1310.4546" target="_blank" rel="noopener">Distributed Representations of Words and Phrases and their Compositionality</a></h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this paper we present several extensions that improve both the quality of the vectors and the training speed. By <code>subsampling of the frequent words</code> we obtain significant speedup and also learn more regular word representations. We also describe a simple alternative to the <code>hierarchical softmax</code> called <code>negative sampling</code>.</p>
<h2 id="Skip-gram-model-1"><a href="#Skip-gram-model-1" class="headerlink" title="Skip-gram model"></a>Skip-gram model</h2><p>Try to maximize the avg log probility:</p>
<script type="math/tex; mode=display">
\frac{1}{T} \sum_{t=1}^{T} \sum_{-c \leq j \leq c, j \neq 0} \log p\left(w_{t+j} \mid w_{t}\right)</script><p>And the probility is calculated using softmax function:</p>
<script type="math/tex; mode=display">
p\left(w_{O} \mid w_{I}\right)=\frac{\exp \left(v_{w o}^{\prime}{\top} v_{w_{I}}\right)}{\sum_{w=1}^{W} \exp \left(v_{w}^{\prime}{ }^{\top} v_{w_{I}}\right)}</script><p>But in actual scene, it’s inpractical because the $\nabla \log p\left(w_{O} \mid w_{I}\right)$ is related to W, usally is very large, so there are some tricks to faster the training process.</p>
<h2 id="Hierarchical-Softmax"><a href="#Hierarchical-Softmax" class="headerlink" title="Hierarchical Softmax"></a>Hierarchical Softmax</h2><p>Using Huffleman tree to reduce the word num in softmax function.</p>
<div align="center">
<img src="/2020/07/28/cs224n-papers/2-1.png" style="width: 95%">
</div>

<h2 id="Negative-Sampling"><a href="#Negative-Sampling" class="headerlink" title="Negative Sampling"></a>Negative Sampling</h2><p>negative sampling has 2 effects that can fast the training process. First is to use $\sigma$: logisitic regression to replace the softmax to represent the probility. Second is to subsample the negative samples. Meanwhile it can just update some of the parameters in backpropogation, because we just random choose k negative samples not all negative samples.</p>
<p>The formula can represent as:</p>
<script type="math/tex; mode=display">
\log \sigma\left(v_{w_{O}}^{\prime}{ }^{\top} v_{w_{I}}\right)+\sum_{i=1}^{k} E_{w_{i} \sim P_{n}(w)}\left[\log \sigma\left(-v_{w_{i}}^{\prime}{ }^{\top} v_{w_{I}}\right)\right]</script><p>To replace the $\log P\left(w_{O} \mid w_{I}\right)$ term in skip-gram.</p>
<h2 id="Subsampling-of-Frequent-Words"><a href="#Subsampling-of-Frequent-Words" class="headerlink" title="Subsampling of Frequent Words"></a>Subsampling of Frequent Words</h2><p>To counter the imbalance between the rare and frequent words, we used a simple subsampling approach: each word $\omega_i$ in the training set is discarded with probability computed by the formula:</p>
<script type="math/tex; mode=display">
P\left(w_{i}\right)=1-\sqrt{\frac{t}{f\left(w_{i}\right)}}</script><p>t is a sample threshold, t is higher means the probility of discarding will go high. And $f(\omega_i)$ means the frequency of word $\omega_i$. </p>
<hr>
<h1 id="GloVe-Global-Vectors-for-Word-Representation"><a href="#GloVe-Global-Vectors-for-Word-Representation" class="headerlink" title="GloVe: Global Vectors for Word Representation"></a><a href="https://nlp.stanford.edu/pubs/glove.pdf" target="_blank" rel="noopener">GloVe: Global Vectors for Word Representation</a></h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>There are two main families in word vector learning:</p>
<ul>
<li><p>global matrix factorization methods, such as latent semantic analysis (LSA)</p>
<ul>
<li>efficiently leverage global statiscal information</li>
<li>But sub-optimal vector space structure</li>
</ul>
</li>
<li><p>local context window methods, such as the skip-gram model</p>
<ul>
<li>poorly utilize the statistics since looking at local context window</li>
</ul>
</li>
</ul>
<h2 id="Glove-Model"><a href="#Glove-Model" class="headerlink" title="Glove Model"></a>Glove Model</h2><h3 id="Some-notations"><a href="#Some-notations" class="headerlink" title="Some notations"></a>Some notations</h3><ul>
<li>$X$: word-word co-occurrence matrix</li>
<li>$X_{ij}$: number of times that j appears in context words of i</li>
<li>$X_i$ = $\sum_{k} X_{ik}$: number of times any word appears<br>in the context of word i</li>
<li>$P_{ij} = P(j | i) = X_{ij} / X_{i}$: probability that word j appear in the context word of i.</li>
</ul>
<h3 id="Insight"><a href="#Insight" class="headerlink" title="Insight"></a>Insight</h3><p>The probability ratio in co-occurrence matrix is better to distingulish relevant words from irrelavant word.</p>
<div align="center">
<img src="/2020/07/28/cs224n-papers/3-1.png" style="width: 95%">
</div>

<h3 id="Formula"><a href="#Formula" class="headerlink" title="Formula"></a>Formula</h3><p>Begin with this insight, then we need to find one formula to optimize it. The ratio mainly related with three words: i, j, k.</p>
<script type="math/tex; mode=display">
F\left(w_{i}, w_{j}, {\tilde{w}}_{k} \right) = \frac{P_{i k}}{P_{j k}}</script><p>Since vector spaces are inherently linear structures, the most natural way to do this is with vector differences. So we can get this formula:</p>
<script type="math/tex; mode=display">
F\left(w_{i}-w_{j}, \tilde{w}_{k} \right)=\frac{P_{i k}}{P_{j k}}</script><p>We notice that the left side is vector and right side is scalar. So we change the formula to:</p>
<script type="math/tex; mode=display">
F\left(\left(w_{i}-w_{j}\right)^{T} \tilde{w}_{k}\right)=\frac{P_{i k}}{P_{j k}}</script><p>Since the F function is required to be homomorphism, so we need the F function to be:</p>
<script type="math/tex; mode=display">
F\left(\left(w_{i}-w_{j}\right)^{T} \tilde{w}_{k}\right)=\frac{F\left(w_{i}^{T} \tilde{w}_{k}\right)}{F\left(w_{j}^{T} \tilde{w}_{k}\right)}</script><p>Together with the two formulas, we can get the following formula:</p>
<script type="math/tex; mode=display">
F\left(w_{i}^{T} \tilde{w}_{k}\right)=P_{i k}=\frac{X_{i k}}{X_{i}}</script><p>Then we can take F as exp function, so we can deduct that:</p>
<script type="math/tex; mode=display">
w_{i}^{T} \tilde{w}_{k}=\log \left(P_{i k}\right)=\log \left(X_{i k}\right)-\log \left(X_{i}\right)</script><p>And we notice that, inorder to keep the exchange symmetry for the left side, so we can add bias term for word i and k, inorder to keep the symmetry. So we can get the final equation:</p>
<script type="math/tex; mode=display">
w_{i}^{T} \tilde{w}_{k}+b_{i}+\tilde{b}_{k}=\log \left(X_{i k}\right)</script><p>Since we get this formula, then we can construct the optimization of the objective function. The objective function is simply an weighted MSE.</p>
<script type="math/tex; mode=display">
J=\sum_{i, j=1}^{V} f\left(X_{i j}\right)\left(w_{i}^{T} \tilde{w}_{j}+b_{i}+\tilde{b}_{j}-\log X_{i j}\right)^{2}</script><p>The $f(X_{ij})$ is to control the weight of the cost function. And the weighting function should obey the following rules:</p>
<ul>
<li>f(0) = 0</li>
<li>non-decreasing function, since rare co-occurrences are not overweighted</li>
<li>should be relatively small for large values of x, so that frequent co-occurrences are not overweighted</li>
</ul>
<p>So the paper gives us a formula:</p>
<script type="math/tex; mode=display">
f(x)=\left\{\begin{array}{cc}
\left(x / x_{\max }\right)^{\alpha} & \text { if } x<x_{\max } \\
1 & \text { otherwise }
\end{array}\right.</script><div align="center">
<img src="/2020/07/28/cs224n-papers/3-2.png" style="width: 95%">
</div>]]></content>
      <categories>
        <category>nlp</category>
      </categories>
      <tags>
        <tag>cs224n</tag>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-solutions</title>
    <url>/2020/08/06/leetcode-solutions/</url>
    <content><![CDATA[<p>This post will mainly and continuously contain the leetcode algorithm problems’ solutions. Trying to force myself to learn something everyday and practice programming skills everyday!</p>
<a id="more"></a>
<h3 id="001-two-sum"><a href="#001-two-sum" class="headerlink" title="001-two-sum"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">001-two-sum</a></h3><p>The problem is trying to find two indices in the input array which their sum is equal to the target.</p>
<p>So we can use the <code>unordered_map</code> to store the value and index. And to test: <code>1: target - num is in the unordered map</code>, <code>2: if contains, the another index should be different from current index.</code></p>
<p>Then we get the two index and return. Here is the solution code.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices_map;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        indices_map[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> another_num = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (indices_map.count(another_num) != <span class="number">0</span> &amp;&amp; i != indices_map[another_num]) &#123;</span><br><span class="line">            results.push_back(i);</span><br><span class="line">            results.push_back(indices_map[another_num]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="002-Add-Two-Numbers"><a href="#002-Add-Two-Numbers" class="headerlink" title="002-Add-Two-Numbers"></a><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">002-Add-Two-Numbers</a></h3><p>This problem mainly inspect the addition of strings(a little like). Because the integer can be very large, bigger than long long, like 1e30 etc. </p>
<p>So we need to find a way to add the two number, that is the string addition. We just need one <code>carry</code> to represent carry bit, initial is 0. </p>
<p>Everytime after we add the correponding position number, the remaining number will be <code>(sum + carry) % 10</code>, and the carry bit will update as <code>(sum + carry) / 10</code>.</p>
<p>Remember that if at last the <code>carry != 0</code>, then we need another node to put the carry in.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = l1-&gt;val + l2-&gt;val;</span><br><span class="line">        ListNode* ptr = <span class="keyword">new</span> ListNode((num + carry) % <span class="number">10</span>);</span><br><span class="line">        carry = (num + carry) / <span class="number">10</span>;</span><br><span class="line">        cur-&gt;next = ptr;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        l1 = l1-&gt;next; l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = l1;</span><br><span class="line">            <span class="keyword">int</span> num = l1-&gt;val + carry;</span><br><span class="line">            l1-&gt;val = num % <span class="number">10</span>;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = l2;</span><br><span class="line">            <span class="keyword">int</span> num = l2-&gt;val + carry;</span><br><span class="line">            l2-&gt;val = num % <span class="number">10</span>;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="003-Longest-Substring-Without-Repeating-Characters"><a href="#003-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="003-Longest-Substring-Without-Repeating-Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">003-Longest-Substring-Without-Repeating-Characters</a></h3><p>This problem is trying to find the <code>longest substring without repreating</code>. The naive way to solve is to examine every substring in input string, but the time complexity is to high(O(n^3)). So I take one optimized solution.</p>
<p>Suppose we have input string <code>abcdcae</code>, and we need one array to examine whether one character is in current substring, so we need <code>int s_index_map[128]</code>, initial is <code>-1</code>, later we will use this to store index.</p>
<p>Then we loop the string, and to test if the current character is in the current substring. we need other params: <code>max_num: the final result</code>, <code>tmp_num: current substring length</code>.</p>
<ul>
<li><p><strong>not in</strong></p>
<ul>
<li><code>tmp_num += 1</code></li>
<li><code>s_index_map[char]</code> = current_index</li>
</ul>
</li>
<li><p><strong>is in</strong></p>
<ul>
<li><code>max_num = max(max_num, tmp_num)</code></li>
<li>find out the old index of the repreated character, which is <code>old_index = s_index_map[c]</code></li>
<li>update the index <code>s_index_map[c] = current_index</code></li>
<li>update tmp_num to length of new substring: <code>tmp_num = cur - old</code></li>
<li>erase the values from the start position to old index position.</li>
</ul>
</li>
</ul>
<p>Take the example of <code>abcdcae</code>, <code>abcd</code> is easy, after these, s[a] = 0, s[b] = 1, … etc. And then <code>c</code> is in, we meet one repeated character right? So take a look of our table, the old <code>c</code> is in <code>index: 2</code> position. So the new substring should start from <code>d</code>, which is <code>index: 3</code> position right, otherwise we still have two <code>c</code>‘s in our string.</p>
<p>So first update <code>max_num = 4</code>, then the <code>old_index = 2</code>, update the index of <code>c</code>, which is set <code>s[c] = 4</code>. Then update the <code>tmp_num</code> to length of new substring <code>&quot;dc&quot;</code>, which is <code>new - old = 4 - 2 = 2</code>. Final step, we should erase the origin substring <code>&#39;a&#39; and &#39;b&#39;</code> index to <code>-1</code>, since they are not in our new substring anymore.</p>
<p>After looping all the characters, do not  forget to take the max value of <code>max_num</code> and <code>tmp_num</code> to get the final answer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s_index_map[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(s_index_map, <span class="number">-1</span>, <span class="keyword">sizeof</span>(s_index_map));</span><br><span class="line">    <span class="keyword">int</span> max_num = <span class="number">0</span>; <span class="keyword">int</span> tmp_num = <span class="number">0</span>; <span class="keyword">int</span> start_pos = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> cur = s[i];</span><br><span class="line">        <span class="keyword">if</span> (s_index_map[cur] == <span class="number">-1</span>) &#123;</span><br><span class="line">            tmp_num += <span class="number">1</span>;</span><br><span class="line">            s_index_map[cur] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max_num = <span class="built_in">std</span>::max(max_num, tmp_num); <span class="comment">// first update max_num, since we met overlap</span></span><br><span class="line">            <span class="keyword">int</span> old_index = s_index_map[cur]; <span class="comment">// old index</span></span><br><span class="line">            s_index_map[cur] = i; <span class="comment">// update index</span></span><br><span class="line">            tmp_num = i - old_index; <span class="comment">// new length</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*erase the values between old char and new char*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start_pos; j &lt; old_index; j++) s_index_map[s[j]] = <span class="number">-1</span>;</span><br><span class="line">            start_pos = old_index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max_num = <span class="built_in">std</span>::max(max_num, tmp_num); <span class="comment">// final update</span></span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="004-Median-of-Two-Sorted-Arrays"><a href="#004-Median-of-Two-Sorted-Arrays" class="headerlink" title="004-Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">004-Median of Two Sorted Arrays</a></h3><p>This problem is to find the median number of two sorted arrays. So we just need another array to store the numbers of two arrays in increasing order. And if we find the middle position, just break.</p>
<p>We have two situations to handle, which is the total length is odd or even.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> l = nums1.size() + nums2.size(); <span class="keyword">double</span> result = <span class="number">0.0</span>; <span class="keyword">bool</span> find_flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums; nums.reserve(l); <span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123;</span><br><span class="line">        nums[index++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];</span><br><span class="line">        <span class="keyword">if</span> (index == l / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            find_flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; !find_flag) &#123;</span><br><span class="line">        nums[index++] = nums1[i++];</span><br><span class="line">        <span class="keyword">if</span> (index == l / <span class="number">2</span> + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums2.size() &amp;&amp; !find_flag) &#123;</span><br><span class="line">        nums[index++] = nums2[j++];</span><br><span class="line">        <span class="keyword">if</span> (index == l / <span class="number">2</span> + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        result = (nums[l / <span class="number">2</span>] + nums[l / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        result = nums[l / <span class="number">2</span>] * <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="005-Longest-Palindromic-Substring"><a href="#005-Longest-Palindromic-Substring" class="headerlink" title="005-Longest-Palindromic-Substring"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">005-Longest-Palindromic-Substring</a></h3><p>This problem is trying to find the lngest palindromic substring of the input string. Suppose the input string s is <code>abcbd</code>, then the output should be <code>bcb</code>.</p>
<p>(1) <strong>Naive solution</strong></p>
<p>The first solution is very simple and easy to understand. I use the two pointer to represent the start and end of one substring. And then loop the <code>length</code> from <code>len(s)</code> to <code>1</code>. Once we found one palindromic substring, then return the result string.</p>
<p>To judge one string is palindromic or not is simple, just to see whether the corresponding character of head and tail is the same.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isp = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ll = l, rr = r; ll &lt;= rr; ll++, rr--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[ll] != s[rr]) &#123;</span><br><span class="line">            isp = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> l = s.length(); <span class="keyword">bool</span> find = <span class="literal">false</span>; <span class="keyword">int</span> i, length;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">for</span> (length = l; length &gt; <span class="number">0</span>; length--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= l - length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[i + length - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(i, i + length - <span class="number">1</span>, s)) &#123;</span><br><span class="line">                find = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (find) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(i, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2) <strong>Dynamic programming solution</strong></p>
<p>In this solution, we define that <code>dp[i][j]</code> represents whether the substring from position <code>i</code> to <code>j</code> is palindromic. </p>
<p>The initial state is <code>dp[i][i] = true</code> and <code>dp[i][i + 1] = s[i] == s[i + 1]</code>. </p>
<p>And we know that if one substring is palindromic, then we add two left and right letters, if the two letter is the same, then the new string is palindromic. Take one example, <code>aba</code> is palindromic, then <code>cabac</code> must be palindromic since <code>c</code> and <code>c</code> is the same.</p>
<p>Then we can deduct the transition equation: <code>dp[i][j] = dp[i + 1][j - 1] &amp;&amp; s[i] == s[j]</code>. So we just need to loop length from 3 to <code>len(s)</code>, we can get the dp array now, the time conplexity is $O(n^2)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">auto</span> length = s.length();</span><br><span class="line">    <span class="keyword">bool</span> dp[length][length];</span><br><span class="line">    <span class="comment">// initial</span></span><br><span class="line">    <span class="keyword">int</span> max_num = <span class="number">-1</span>, mi = <span class="number">0</span>, mj = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        dp[i][i + <span class="number">1</span>] = s[i] == s[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (dp[i][i + <span class="number">1</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">            max_num = <span class="number">2</span>;</span><br><span class="line">            mi = i; mj = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[length - <span class="number">1</span>][length - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// transition equation</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t_length = <span class="number">3</span>; t_length &lt;= length; t_length++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length - t_length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + t_length - <span class="number">1</span>;</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] == <span class="literal">true</span> &amp;&amp; t_length &gt; max_num) &#123;</span><br><span class="line">                max_num = t_length;</span><br><span class="line">                mi = i; mj = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(mi, mj - mi + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="006-ZigZag-Conversion"><a href="#006-ZigZag-Conversion" class="headerlink" title="006-ZigZag-Conversion"></a><a href="https://leetcode.com/problems/zigzag-conversion/" target="_blank" rel="noopener">006-ZigZag-Conversion</a></h3><p>This problem is to write the input string in a new zigzag form. So I use two-dimension vector to simulate the writing process. Notice one particur case: if <code>numRows = 1</code>, our index should just stay as <code>0</code>. Here is the code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; c_vec (numRows); <span class="keyword">int</span> c = <span class="number">0</span>; <span class="keyword">bool</span> up_flag = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) up_flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == numRows - <span class="number">1</span>) up_flag = <span class="literal">false</span>;</span><br><span class="line">        c_vec[c].push_back(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (numRows != <span class="number">1</span>) &#123;</span><br><span class="line">            c = up_flag ? c + <span class="number">1</span> : c - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c_vec.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c_vec[i].size(); j++) &#123;</span><br><span class="line">            r.push_back(c_vec[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="007-Reverse-Integer"><a href="#007-Reverse-Integer" class="headerlink" title="007-Reverse-Integer"></a><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">007-Reverse-Integer</a></h3><p>The problem is easy, we only need to consider in which case the reversed number will overflow. Since we will use annotation <code>r</code> to represent the intermediate result. So if <code>r &lt;= INT_MAX / 10</code>, then we can continue, otherwise just return 0.</p>
<p>The other thing is that we simplily notice the sign that is ok!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign = (x &lt; <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= INT_MAX / <span class="number">10</span>) &#123;</span><br><span class="line">            r = r * <span class="number">10</span> + <span class="built_in">abs</span>(x % <span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="008-String-to-Integer-atoi"><a href="#008-String-to-Integer-atoi" class="headerlink" title="008-String to Integer (atoi)"></a><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">008-String to Integer (atoi)</a></h3><ul>
<li>First find out the first not <code>whitespace</code> character</li>
<li>if not <code>-</code> or <code>+</code> or digits, return 0</li>
<li>if <code>-</code> or <code>+</code>, add to minus flag <code>-1</code>, <code>1</code>.</li>
<li><p>Then judge whether overflow</p>
<ul>
<li><code>result &gt; INT_MAX / 10) || (result == INT_MAX / 10 &amp;&amp; c &gt;= 7</code> return <code>INT_MAX</code> when result is positive</li>
<li><code>result &lt; INT_MIN / 10 || (result == INT_MIN / 10 &amp;&amp; c &gt;= 8</code> return <code>INT_MIN</code> when result is negative</li>
<li><code>INT_MAX=2147483647</code>, <code>INT_MIN=-2147483648</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s; <span class="keyword">int</span> minus_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// find the first not ""</span></span><br><span class="line">    <span class="keyword">int</span> index = str.find_first_not_of(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[index] == <span class="string">'-'</span> || str[index] == <span class="string">'+'</span>) &#123;</span><br><span class="line">        minus_flag = str[index] == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(str[index])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &lt; str.length(); index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(str[index])) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> c = str[index] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (minus_flag == <span class="number">1</span> &amp;&amp; (result &gt; INT_MAX / <span class="number">10</span>) || (result == INT_MAX / <span class="number">10</span> &amp;&amp; c &gt;= <span class="number">7</span>)) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (minus_flag == <span class="number">-1</span> &amp;&amp; (result &lt; INT_MIN / <span class="number">10</span> || (result == INT_MIN / <span class="number">10</span> &amp;&amp; c &gt;= <span class="number">8</span>))) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        result = result * <span class="number">10</span> + minus_flag * c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="009-Palindrome-Number"><a href="#009-Palindrome-Number" class="headerlink" title="009-Palindrome-Number"></a><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">009-Palindrome-Number</a></h3><p>This problem is very easy. Since the negative number is definitely not palindromic, so <code>if x &lt; 0: return false</code>. Then just get every number of input x, and to loop from left to right and right to left, to examine whether the corresponding character is the same.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> vec[<span class="number">10</span>]; <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        vec[index++] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = index - <span class="number">1</span>; i &lt;= j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i] != vec[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="011-Container-With-Most-Water"><a href="#011-Container-With-Most-Water" class="headerlink" title="011-Container-With-Most-Water"></a><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">011-Container-With-Most-Water</a></h3><p>The thought is a little like greedy algorithm. We will compare the left and right height, and to replace the shorter one with the adjacent line. Since the area is depends on the shorter line, so we will replace shorter one inorder to get larger area.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = height.size() - <span class="number">1</span>; <span class="keyword">int</span> max_num = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        max_num = max(max_num, (j - i) * min(height[i], height[j]));</span><br><span class="line">        height[i] &lt; height[j] ? i++ : j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="012-Integer-to-Roman"><a href="#012-Integer-to-Roman" class="headerlink" title="012-Integer-to-Roman"></a><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">012-Integer-to-Roman</a></h3><p>Just loop the predefined symbols and corresponding ints. If contain some symbols multiple times, just add into result string.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; symbols &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; symbol_ints &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; symbols.size() &amp;&amp; num != <span class="number">0</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num / symbol_ints[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            s += symbols[i];</span><br><span class="line">            num -= symbol_ints[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="013-Roman-to-Integer"><a href="#013-Roman-to-Integer" class="headerlink" title="013-Roman-to-Integer"></a><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">013-Roman-to-Integer</a></h3><p>My solution is first to insert the pairs into one map. And then to scan the input string, first to find whether <code>&quot;xx&quot;</code> is in the input string, if not then find <code>&quot;x&quot;</code>, and add the corresponding result can get the final answer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; symbols &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; symbol_ints &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; symbol_map; <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; symbols.size(); i++) &#123;</span><br><span class="line">        symbol_map[symbols[i]] = symbol_ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            c += symbol_map[s.substr(i)];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (symbol_map.count(s.substr(i, <span class="number">2</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">                c += symbol_map[s.substr(i, <span class="number">2</span>)];</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                c += symbol_map[s.substr(i, <span class="number">1</span>)];</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="014-Longest-Common-Prefix"><a href="#014-Longest-Common-Prefix" class="headerlink" title="014-Longest-Common-Prefix"></a><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">014-Longest-Common-Prefix</a></h3><p>This problem is easy. We need to find the longest common prefix in the input vectors. So we just take first two strings, and find the <code>LCP</code>. Then use this <code>LCP</code> to process with later string, get another <code>LCP</code>.</p>
<p>if <code>LCP</code> comes to <code>&quot;&quot;</code>, just return. Else we return the final <code>LCP</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">CommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min(s1.length(), s2.length()); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] != s2[i]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.substr(<span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">auto</span> str = strs.front();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        str = CommonPrefix(str, strs[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">""</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="015-3Sum"><a href="#015-3Sum" class="headerlink" title="015-3Sum"></a><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">015-3Sum</a></h3><p>The main difficulty of the this problem is forcing to find the <code>unique triplets</code>. So at first I tried to use the two pointers, it’s hard to control the range since the ranges will have overlap, this will lead to duplicate results.</p>
<p>So we can simply fix one side, and this can prevent the duplicate. First we will <code>sort the array</code>, and fix the left index as i, and then we will judge <code>nums[i] + nums[i + 1] + nums[j] = 0(?)</code>. if yes, then move the right pointer to left, continue to find out all answers in this range, if no, there are two situations.</p>
<ul>
<li>sum &lt; 0, then we need to move the <code>l = i + 1</code> to right</li>
<li>sum &gt; 0, then we need to move the <code>r</code> to left</li>
</ul>
<p>And remember that there will be same values occur, so we need to skip these same values to another distinct value to continue our process.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt;= <span class="number">2</span>) <span class="keyword">return</span> vec;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums.front() &gt; <span class="number">0</span> || nums.back() &lt; <span class="number">0</span>) <span class="keyword">return</span> vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t &#123;nums[i], nums[l], nums[r]&#125;;</span><br><span class="line">                    vec.push_back(t);</span><br><span class="line">                    r--;</span><br><span class="line">                    <span class="keyword">for</span> (; l &lt; r; r--) <span class="keyword">if</span> (nums[r] != nums[r + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="keyword">for</span> (; l &lt; r; l++) <span class="keyword">if</span> (nums[l] != nums[l - <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                    <span class="keyword">for</span> (; l &lt; r; r--) <span class="keyword">if</span> (nums[r] != nums[r + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138-Copy-List-with-Random-Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138-Copy-List-with-Random-Pointer</a></h3><p>This problem is trying to make a deep copy of the origin list. The main thought is to find the random pointer’s position in the origin list, so here I find two solutions for this problem.</p>
<p>(1) Using unordered_map</p>
<ul>
<li>Using one vector to store the new list</li>
<li>Using one map to map the <code>Node*</code> to <code>index</code>.</li>
<li>Loop the vector, link the next pointer.</li>
<li>Then loop the origin list, link the random pointer</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node* dummy = head; <span class="built_in">unordered_map</span>&lt;Node*, <span class="keyword">int</span>&gt; node_index_map; <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dummy != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        node_index_map[dummy] = c++;</span><br><span class="line">        dummy = dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* nodes[c]; nodes[<span class="number">0</span>] = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c; i++) &#123;</span><br><span class="line">        nodes[i] = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        nodes[i - <span class="number">1</span>]-&gt;next = nodes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nodes[c]-&gt;val = head-&gt;val;</span><br><span class="line">        nodes[c++]-&gt;random = head-&gt;random == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : nodes[node_index_map[head-&gt;random]];</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2) Not using map</p>
<p>If not using map, then we need to connect the new list and the origin list first. So the procedue can be:</p>
<ul>
<li>Copy the origin list, and insert behind the origin list for every node corresponding. For example: <code>1-&gt;2-&gt;3</code> -&gt; <code>1-&gt;1&#39;-&gt;2-&gt;2&#39;-&gt;3-&gt;3&#39;</code>.</li>
<li>Then link the random pointer for the new list.</li>
<li>Break the connection between new list and origin list.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Node* dummy = <span class="keyword">new</span> Node(<span class="number">0</span>); Node* t = dummy; Node* h = head; <span class="built_in">vector</span>&lt;Node*&gt; vec;</span><br><span class="line">    Node* tmp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        dummy-&gt;val = head-&gt;val;</span><br><span class="line">        dummy-&gt;random = head;</span><br><span class="line">        vec.push_back(dummy);</span><br><span class="line">        tmp = head; dummy-&gt;next = head-&gt;next; head = head-&gt;next;</span><br><span class="line">        tmp-&gt;next = dummy; dummy = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)&#123;</span><br><span class="line">        dummy = vec[i];</span><br><span class="line">        <span class="keyword">if</span> (dummy-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            dummy-&gt;random = (dummy-&gt;random-&gt;random == <span class="literal">nullptr</span>) ? <span class="literal">nullptr</span> : dummy-&gt;random-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head = h;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        head-&gt;next = (head-&gt;next == <span class="literal">nullptr</span>) ? <span class="literal">nullptr</span> : head-&gt;next-&gt;next;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    dummy = t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size() - <span class="number">1</span>; i++) vec[i]-&gt;next = vec[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>machine-learning-2-Linear-Regression</title>
    <url>/2019/07/05/machine-learning-2-Linear-Regression/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在前一篇文章当中，我们详细的讨论了Bayes分类器，使用的是后验概率$p(\omega_i|x)$作为它的discriminant function. 那既然监督学习的目标就是学一个mapping，Bayes的方法虽然最优，但并不是直接从data当中得到，所以今天我们将主要介绍Linear model.</p>
<a id="more"></a>
<h3 id="Linear-methods-for-Regression"><a href="#Linear-methods-for-Regression" class="headerlink" title="Linear methods for Regression"></a>Linear methods for Regression</h3><ul>
<li><strong>Linear model</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Linear model 的表达形式很简单，就是类似于平时我们见到的一次方程，即从x到y的mapping函数为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x) &= \omega^TX \\\\
\omega \in R^{d+1} &= [\omega_1, \omega_2, ... , \omega_d, b]^T \\\\
X \in R^{d+1} &= [x_1, x_2, ... , x_d, 1]^T 
\end{aligned}</script><p><br></p>
<ul>
<li><strong>Error function</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在linear model当中，我们的目标变成了优化一个objective function，使得这个损失函数取到最小值，在linear model当中，objective function常见有两种，当然也是大同小异的：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>(1)Mean sum of square error:</strong></p>
<script type="math/tex; mode=display">
MSE(a) = \frac{1}{n}\sum_{i=1}^n(y_i - f(x_i, a))^2</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>(2)Redual sum of square error:</strong></p>
<script type="math/tex; mode=display">
RSS(a) = \sum_{i=1}^n(y_i-f(x_i, a))^2</script><p><br></p>
<ul>
<li><strong>Optimize</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在我们得到了linear model的objective function之后，我们的目标就是找到一组参数$a$，使得上述两个objective function能够在training data上面取最小值，当然可以看到RSS和MSE其实都是用的<code>最小二乘法</code>的思想，优化目标都是一样的。我们对数据进行矩阵化的表示，$X = [x_1, x_2, … , x_n], y=[y_1, y_2, … , y_n]^T$.</p>
<script type="math/tex; mode=display">
\begin{aligned}
J_n(a) &= (y-X^Ta)^T(y-X^Ta) \\\\
\nabla_aJ_n(a) &= -2X(y-X^Ta) = 0 \\\\
a &= (XX^T)^{-1}Xy
\end{aligned}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 哦豁，到这里好像事情变得很简单，只需要对RSS求个导就能得到最优的参数解。当然，事情是没有想象的那么简单的，我们看$a = (XX^T)^{-1}Xy$, 如果$XX^T$不满秩的情况下，这个方程还能用吗，那当然是不能用了，因为$XX^T$都不能求逆了，怎么用！所以这个方程在$XX^T$满秩时有解，不满秩的时候存在无穷多解，也即overfitting problem.</p>
<p><br></p>
<ul>
<li><strong>Statistic model of regression</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这个part将会通过统计回归模型来推导linear model 的 objective function. 使用统计回归模型的时候，我们首先会假设存在一个隐含变量$\epsilon$, 所以我们linear model的表示形式就变成了：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y &= f(x, a) + \epsilon &
\epsilon \sim N(0, \sigma^2)
\end{aligned}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后我们使用MLE的方法来最大化log-似然函数，所以整个推导过程如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
l(D, a, \sigma) &= ln(l(D, a, \sigma)) \\\\
&= \sum_{i=1}^n lnp(y_i|x_i, a, \sigma) \\\\
&= \sum_{i=1}^n ln[\frac{1}{\sigma \sqrt{2\pi}}e^{-\frac{1}{2\sigma^2}(y-f(x, a))^2}] \\\\
&= -\frac{1}{2\sigma^2}\sum_{i=1}^n(y-f(x, a))^2 + c(\sigma)
\end{aligned}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OK, Fine.这里我们看到当极大化似然函数的时候，我们得到和MSE或者是RSS的优化函数是一样的，所以这两种优化目标是相同的。</p>
<p><br></p>
<ul>
<li><strong>Over-fitting</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Overfitting problem 是机器学习问题当中很常见的问题，当选取的参数过多，而没有足够多的样本来支持的话，所以就会出现<code>模型过拟合</code>的问题。具体可以用以下这张图展示：</p>
<p><img src="/2019/07/05/machine-learning-2-Linear-Regression/1.png" style="width: 80%"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在之前的$a = (XX^T)^{-1}Xy$ 表达式当中，如果$XX^T$不满秩的话，最后结果导致就是<code>overfitting problem</code>.</p>
<p><br></p>
<ul>
<li><strong>Ridge Regression</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 出了问题那就得解决是吧，出现了<code>overfitting</code>那么我们就得想办法解决这个问题。也就引出了接下来要阐述的<code>正则化</code>的解决方法。</p>
<script type="math/tex; mode=display">
a^* = argmin(\sum_{i=1}^n(y_i-x_i^Ta)^2 + \lambda\sum_{j=1}^pa_j^2)</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同样的添加正则项，同样也相当于给之前的objective function加上限制，也即：</p>
<script type="math/tex; mode=display">
\begin{aligned}
a^* = argmin(\sum_{i=1}^n(y_i-x_i^Ta)^2) && s.t.\lambda\sum_{j=1}^pa_j^2\le t
\end{aligned}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后对加上正则项的objective function进行求导然后就能求得极值。其实加上正则项的意义就在于，对于参数$a$进行惩罚，其中的参数$\lambda$就是对这两项进行相对应的调整，来决定这两项的比重。</p>
<script type="math/tex; mode=display">
a^* = (XX^T+\lambda I)^{-1}Xy</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以看一下参数$\lambda$对整个model的影响，当$\lambda$很大的时候，相当于正则加的很大，使得参数都很小，会使得$bias$变大。如果$\lambda$很小的时候，相当于是$variance$相对大一点。但是因为我们加上正则项，所以training error是不可避免的会增加，所以我们需要寻找的就是training error和testing error都相对偏小的那个平衡值：</p>
<p><img src="/2019/07/05/machine-learning-2-Linear-Regression/2.png" style="width: 80%"></p>
<p><br></p>
<ul>
<li><strong>LASSO</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在上面我们提到正则项加的是$\lambda\sum_{j=1}^pa_j^2$, 这是很常用的<code>L2 norm</code>, 如果我们用一阶来做正则的话，就有一个新的名字，叫做<code>LASSO</code>,<code>LASSO</code>是一个<code>Sparse model</code>，也即自带<code>featrue select</code>的功能，<code>LASSO</code>的表达形式为：</p>
<script type="math/tex; mode=display">
a^*=argmin(\sum_{i=1}^n(y_i-x_i^Ta)^2+\lambda\sum_{j=1}^p|a_j|)</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么说LASSO是一个Sparse model呢，我们从objective function的图形化表示来看就很容易理解，因为两条线的相切的地方总是在角点。所以很多项的参数就自动变成了0:</p>
<p><img src="/2019/07/05/machine-learning-2-Linear-Regression/3.png" style="width: 80%"></p>
<p><br></p>
<ul>
<li><strong>Bias and variance decomposition</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后这里对<code>bias</code>和<code>variance</code>做一个讨论。<code>bias</code>主要指的是最后学到的model和真实的model之间的偏差，<code>variance</code>指的是每次学到的model之间误差值，<code>noise</code>是不可避免的误差，所以不能做到完全optimal的model.我们使用<code>EPE</code>进一步的衡量model loss：</p>
<script type="math/tex; mode=display">
\begin{aligned}
EPE(f) &= \iint(y-f(x))^2p(x, y)dxdy \implies \\\\
EPE(f) &= (bias)^2+variance+noise \\\\
(bias)^2 &= \int[E_D(f(x;D)-E(y|x))]^2p(x)dx \\\\
variance &= \int E_D[f(x;D)-E_D(f(x;D))]^2p(x)dx \\\\
noise &= \int var(y|x)p(x)dx
\end{aligned}</script><p><img src="/2019/07/05/machine-learning-2-Linear-Regression/4.png" style="width: 80%"></p>
]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title>machine-learning-3-Linear-Classifier</title>
    <url>/2019/07/05/machine-learning-3-Linear-Classifier/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在前一篇文章当中，我们详细的阐述了Linear model的表现，不过它主要做的是<code>supervised learning</code>当中的一个<code>regression</code>问题，那还剩下另外一个比较重要的问题：<code>classification</code>.所以在这一篇文章当中，会主要介绍<code>logistic model</code>和<code>SVM</code>两种<code>linear classifier</code>.</p>
<a id="more"></a>
<h3 id="Sigmoid-function-logistic-function"><a href="#Sigmoid-function-logistic-function" class="headerlink" title="Sigmoid function (logistic function)"></a>Sigmoid function (logistic function)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sigmoid function 是 logistic regression当中最重要的一个元函数。我们也叫它<code>S型函数</code>：</p>
<script type="math/tex; mode=display">
\sigma(t) = \frac{e^t}{1+e^t} = \frac{1}{1+e^{-t}}</script><p><img src="/2019/07/05/machine-learning-3-Linear-Classifier/1.png" style="width: 50%"></p>
<p><br></p>
<h3 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 逻辑斯蒂回归是一种<code>classification</code>的方法，利用的就是sigmoid function来进行classify. Logistic Regression的主要形式如下：</p>
<script type="math/tex; mode=display">
p(y_i=\pm1|x_i, a) = \sigma(y_ia^Tx_i) = \frac{1}{1+e^{-y_ia^Tx_i}}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后对于数据我们同样使用的<code>MLE</code>的方法来估计参数$a$.</p>
<script type="math/tex; mode=display">
l(p(D)) = -\sum_{i \in I}\log(1+e^{-y_ia^Tx_i})</script><script type="math/tex; mode=display">
E(a) = \sum_{i \in I}\log(1+e^{-y_ia^Tx_i})</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是注意的是$E(a)$是一个non-convex function对于参数$a$而言。换言之这里直接求导是没用的，所以我们引入一个新的求参数最值的方法：<a href="https://zh.wikipedia.org/zh-hans/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95" target="_blank" rel="noopener">Gradient descent</a></p>
<p><br></p>
<h3 id="Gradient-descent"><a href="#Gradient-descent" class="headerlink" title="Gradient descent"></a>Gradient descent</h3><ul>
<li>first order optimization problem (通过求解一阶导可以求解)</li>
<li>Can find a <code>local optimum</code></li>
<li>梯度相反方向：<code>local minimum</code>, 梯度方向：<code>local maximum</code></li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
\omega_{n+1} = \omega_n - \gamma \nabla J(\omega_n) && n \ge 0
\end{aligned}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实这只是一阶导下面的梯度下降的方法，我们来看一看为什么可以进行梯度下降，或者说梯度下降为什么会work呢？</p>
<script type="math/tex; mode=display">
E(a+\triangle a) = E(a) + E' (a)\triangle a + E'' (a)\frac{(\triangle a)^2}{2!} + ...</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是大家很熟悉的拉格朗日展开，如果我们只取前两项进行估计，则有$E(a)+E’ (a)\triangle a \implies \triangle a = -\eta E’ (a)$.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果是采用前三项进行估计，那么这个叫做<code>牛顿法估计</code>，那么在这种估计之下我们会有：</p>
<script type="math/tex; mode=display">
E' (a)\triangle a + E'' (a)\frac{(\triangle a)^2}{2!} \implies E' (a)+E'' (a)\triangle a = 0 \implies \triangle a = -\frac{E' (a)}{E'' (a)}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于牛顿法求梯度下降更通用的写法如下所示，本质也就是上面式子推导而来：</p>
<script type="math/tex; mode=display">
\triangle a = -\eta [HE(a)]^{-1} E' (a)</script><p><br></p>
<h3 id="Regularized-Logistic-Regression"><a href="#Regularized-Logistic-Regression" class="headerlink" title="Regularized Logistic Regression"></a>Regularized Logistic Regression</h3><ul>
<li><strong>L2-Regularizer</strong></li>
<li><strong>L1-Regularizer</strong> (Sparse Logistic Regression)</li>
</ul>
<script type="math/tex; mode=display">
E(a) = \sum_{i \in I}\log(1+e^{-y_ia^Tx_i}) + \lambda\sum_{j=1}^p(a_j^2)</script><p><br></p>
<h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们知道，对于一个线性可分的数据集，他的solution vector $a$ 可以有无数条，只要能够将两种数据给分开就行。那么我们就想，这么多个solution vector当中，哪条是最优的呢？这就引出今天的另一位主角，就是<a href="https://zh.wikipedia.org/wiki/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA" target="_blank" rel="noopener">SVM-solution vector machine</a>, 也称为<code>large margin classifier</code>.</p>
<ul>
<li><strong>Geometrical Margin</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 已知solution vector $\omega$, 如何计算任意一个点x到分割面的距离呢：<br><img src="/2019/07/05/machine-learning-3-Linear-Classifier/4.png" style="width: 40%"></p>
<script type="math/tex; mode=display">
x = x_0+\frac{y\gamma\omega}{||\omega||}</script><script type="math/tex; mode=display">
\omega^Tx = \omega^T(x_0+\frac{y\gamma\omega}{||\omega||}) + b = 0</script><script type="math/tex; mode=display">
\implies \gamma = y\frac{\omega^Tx+b}{||\omega||}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中的$\gamma$就被称为<code>Geometrical Margin</code>, 从上面的式子当中我们很容易看出来其实$|f(x)|$就可以衡量不同点到分割面之间的距离。</p>
<p><br></p>
<ul>
<li><strong>Margin of dataset</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们把一个数据集的Margin规定为数据集当中到分割面最小的$\gamma$称为数据集的Margin. 然后我们的target同理也可以变为：Find the hyperplane with the largest margin. 同时我们把那些决定hyperplane的点称为<code>support vectors</code>, 因为远的点对dataset margin没有任何影响，而只有那些组成dataset margin的点才是我们需要关注的点。</p>
<script type="math/tex; mode=display">
max_{\omega, b}\gamma = max_{\omega, b}\frac{y(\omega^Tx+b)}{||\omega||}(\gamma_i \ge \gamma)</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为在这里$\omega$是可以进行任意缩放的，并不会对hyperlane造成任何的影响，所以做一个处理，Fix $y(\omega^Tx+b) = 1 \implies \gamma ||\omega|| = 1$</p>
<script type="math/tex; mode=display">
max_{\omega, b}\frac{y(\omega^Tx+b)}{||\omega||} = max\frac{1}{||\omega||}</script><script type="math/tex; mode=display">
\gamma_i = \frac{y_i(\omega^Tx_i+b)}{||\omega||} \ge \gamma \implies y_i(\omega^Tx_i+b) \ge 1</script><script type="math/tex; mode=display">
max\frac{1}{||\omega||} \implies min\frac{1}{2}||\omega^2||</script><script type="math/tex; mode=display">
\begin{aligned}
min\frac{1}{2}||\omega^2|| && s.t. && y_i(\omega^Tx_i+b) \ge 1
\end{aligned}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以我们最后的优化目标就变成了上面这个式子了！但是这个式子有一个很明显的weakness：容易受到噪声noise的影响，<code>因为是不允许任何出错的情况的</code>，我们可以看一下如果有一个分类错误的，会影响整个hyperlane的选取：</p>
<p><img src="/2019/07/05/machine-learning-3-Linear-Classifier/2.png" style="width: 40%"></p>
<p><br></p>
<ul>
<li><strong>Slack variables</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了解决上面的问题，我们引入一个<code>slack variable</code>, 即这个时候我们允许一些犯错，所以我们的新的objective function为：</p>
<script type="math/tex; mode=display">
min_{\omega, b}\frac{1}{2}||\omega^2||+c\sum_{i=1}^n\xi_i</script><script type="math/tex; mode=display">
\begin{aligned}
y_i(\omega^Tx_i+b) \ge 1-\xi_i && \xi_i \ge 0 \implies \xi_i = max[0, 1-y_i(\omega^Tx_i+b)]
\end{aligned}</script><script type="math/tex; mode=display">
E(\omega) = \sum_{i=1}^nmax[0, y_i(\omega^Tx_i+b)] + \frac{1}{2c}||\omega^2||</script><p><br></p>
<ul>
<li><strong>General formulation of classifiers</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不知道有没有发现，我们之前阐述的objective function都有一个共性，也即<code>Loss function + Regularizer</code>, 即$min\sum_{i=1}^nl(f) + \lambda R(f)$. 所以我们可以总结出这几种loss：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>square loss</code>: $l = (1-yf)^2$<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>logistic loss</code>: $l = log(1+e^{-yf})^2$<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Hinge loss</code>: $l = max[0, 1-yf]$</p>
<p><img src="/2019/07/05/machine-learning-3-Linear-Classifier/3.png" style="width: 50%"></p>
]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title>machine-learning-4-Kernel-Function</title>
    <url>/2019/07/06/machine-learning-4-Kernel-Function/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在前面几篇文章当中介绍的<code>Linear model</code>, <code>logistic regression</code>, <code>SVM</code>这几种supervised learning的分类器，但是他们只能handle linear的情况，对于非线性可分的情况就爱莫能助了，所以这里主要介绍kernel核方法来讨论non-linear的情况。</p>
<a id="more"></a>
<h3 id="Generalized-Linear-Function"><a href="#Generalized-Linear-Function" class="headerlink" title="Generalized Linear Function"></a>Generalized Linear Function</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一组数据在当前维度下线性不可分，我们可以对这个维度的数据进行mapping，也即映射到更高维的数据，在高维的空间当中就可能是线性可分的，也就可以利用我们之间介绍的一系列的方法，下面是一个mapping的例子🌰：</p>
<p><img src="/2019/07/06/machine-learning-4-Kernel-Function/1.png" style="width: 50%"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面我们介绍一下什么叫做<code>Generalized Linear Function</code>, 简单来说就是在linear model的基础之上，增加相关变量。也即在linear model当中我们有$[x_1, x_2, x_3]$这三个featrue，我们增加与三个feature相关的变量，也即扩展到$[x_1, x_2, x_3, x_1x_2, x_1x_3, x_2x_3]$.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来就是在这个新的featrue space去学一个线性的分类器即可。</p>
<p><br></p>
<h3 id="Quadratic-Discriminant-Function"><a href="#Quadratic-Discriminant-Function" class="headerlink" title="Quadratic Discriminant Function"></a>Quadratic Discriminant Function</h3><script type="math/tex; mode=display">
g(x) = \omega_0 + \sum_{i=1}^d\omega_ix_i + \sum_{i=1}^d \sum_{j=1}^d \omega_{ij}x_ix_j</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $g(x) = 0$ 代表的就是一个超平面，在新的映射的featrue space里面的超平面，将数据分割成两类。</p>
<p><br></p>
<h3 id="Generalized-Discriminant-Function"><a href="#Generalized-Discriminant-Function" class="headerlink" title="Generalized Discriminant Function"></a>Generalized Discriminant Function</h3><script type="math/tex; mode=display">
g(x) = \sum_{i=1}^{\hat{d}}a_iy_i(x) = a^Ty</script><script type="math/tex; mode=display">
\begin{aligned}
a = [a_1, a_2, ..., a_d]^T && y = [y_1(x), y_2(x), ..., y_d(x)]^T
\end{aligned}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中的mapping y叫做<code>augmented featrue vector</code>, 或者叫做<code>phi function</code>.</p>
<p><br></p>
<h3 id="Representer-Theorm"><a href="#Representer-Theorm" class="headerlink" title="Representer Theorm"></a>Representer Theorm</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们后面也介绍的kernel function都是建立在<a href="http://web.eecs.umich.edu/~cscott/past_courses/eecs598w14/notes/13_kernel_methods.pdf" target="_blank" rel="noopener">Representer Theorm</a>的基础之上。这里我只简单的介绍一下形式，具体形式可以查看链接当中PDF的详细介绍。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之，这个定理描述的就是，任何形如 <code>loss function + Reguralizer</code>的函数都能这样被表示：</p>
<script type="math/tex; mode=display">
f(x) = \sum_{i=1}^n\alpha_ik(x_i, x)</script><p><br></p>
<h3 id="Kernelized-Ridge-Regression"><a href="#Kernelized-Ridge-Regression" class="headerlink" title="Kernelized Ridge Regression"></a>Kernelized Ridge Regression</h3><script type="math/tex; mode=display">
\begin{aligned}
\omega^* &= argmin\sum_{i=1}^n(y_i-x_i^T\omega)^2 + \lambda\sum_{j=1}^p \omega_j^2 \\\\
&= (XX^T + \lambda I)^{-1}Xy \\\\
&= X(X^TX+\lambda I)^{-1}y \\\\
\alpha &= (X^TX+\lambda I)^{-1}y \\\\
\omega^* &= X\alpha = \sum_{i=1}^n \alpha_ix_i
\end{aligned}</script><script type="math/tex; mode=display">
f(x) = \omega^Tx = \sum_{i=1}^n\alpha_ix_i^Tx = \sum_{i=1}^n \kappa(x_i, x)</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中的$\kappa(x_i, x)$就是ridge regression的kernel function，只要来一个x，只需要放到这个kernel function当中计算一下就fine了。</p>
<p><br></p>
<h3 id="Kernels"><a href="#Kernels" class="headerlink" title="Kernels"></a>Kernels</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Let $\kappa(x_i, x) \ge 0$ be some measure of similarity of $(x_i, x)$, we will call $\kappa$ a <code>kernel function</code>. 一般来说$\kappa$都是对称的，并且是positive的，下面是一些常用的kernel function：</p>
<ul>
<li><strong>linear kernel</strong>: $\kappa(x, x’) = x^Tx_i$</li>
<li><strong>Polinominal kernel:</strong> $\kappa(x, x’) = (x^Tx’ + 1)^d$</li>
<li><strong>RBF kernel:</strong> $\kappa(x, x’) = exp(-\frac{||x-x’||^2}{2\sigma^2})$</li>
</ul>
<p><br></p>
<h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul>
<li><strong>Non-linear function</strong></li>
<li><strong>Works when the samples can’t represent as featrue vectors</strong></li>
<li><strong>String kernels, graph kernels, etc.</strong></li>
</ul>
]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title>machine-learning-1-DM-and-Bayesian</title>
    <url>/2019/06/29/machine-learning-1-DM-and-Bayesian/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在这个系列的博客文章里面，主要记录的是本学期《数据挖掘导论》课程当中的知识点，涉及的是传统机器学习当中的算法，包括有监督学习、无监督学习这两大部分。这篇博客文章主要记录的是machine learning简介以及Bayesian的相关内容。<br><a id="more"></a></p>
<h3 id="1-What-is-machine-learning"><a href="#1-What-is-machine-learning" class="headerlink" title="1. What is machine learning"></a>1. What is machine learning</h3><h4 id="Two-kinds-of-problems"><a href="#Two-kinds-of-problems" class="headerlink" title="Two kinds of problems"></a>Two kinds of problems</h4><ul>
<li>监督学习(supervised learning)</li>
<li>无监督学习(unsupervised learning)</li>
<li>Differences:</li>
</ul>
<ol>
<li>Supervised learning is trying to <code>find a mapping from x to y</code>, 比如说是<code>classfication</code>或者是<code>regression</code>的问题。</li>
<li>unsupervised learning问题是只有无label的样本数据，我们需要寻找<code>interesting patterns</code>, 比如说是聚类(clusters)、降维、矩阵分解(latent factors)等内容。 </li>
</ol>
<ul>
<li>Supervised learning: <code>collecting samples -&gt; define featrues -&gt; design and build models -&gt; make prediction</code></li>
<li><p>Good representation for featrues:</p>
<ul>
<li><code>Low intra-class variability</code></li>
<li><code>Low inter-class similarity</code></li>
</ul>
</li>
<li><p>Bias and variance trade-off(偏差和方差之间的权衡，主要是下面这张图体现)：</p>
</li>
</ul>
<p><img src="/2019/06/29/machine-learning-1-DM-and-Bayesian/1.png" alt></p>
<ul>
<li><strong>Genelization(模型的泛化能力)</strong>：The performance on the <strong>testing</strong> data. 简单的模型的Train error更大，相对而言越复杂的模型的Train error会相对更小，但是Test error就不确定了，主要要参考bias和variance这两个基准来进行考量。</li>
</ul>
<h3 id="2-Bayesian"><a href="#2-Bayesian" class="headerlink" title="2. Bayesian"></a>2. Bayesian</h3><ul>
<li>Bayes’ Theorem 贝叶斯定理（这里我们只需要掌握贝叶斯公式即可）<script type="math/tex; mode=display">
P(A|B) = \frac{P(B|A) * P(A)}{P(B)}</script></li>
<li><strong>Prior</strong>: 先验知识，也即在进行分类之前我们能够得知的已知的样本信息，如果只是简单的根据先验知识来进行分类的话，只需要判断$\omega_1$ if $p(\omega_1) &gt; p(\omega_2)$ else $\omega_2$.</li>
<li><strong>likelihood</strong>: 似然，这里主要引进的是<strong>最大似然估计</strong><br>&nbsp;&nbsp;&nbsp; Assign input pattern $x$ to class $\omega_1$ if $p(x|\omega_1) &gt; p(x|\omega_2)$ else $\omega_2$.</li>
<li><strong>Posterior</strong>: 后验概率，在贝叶斯模型当中非常重要的一个点.</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
p(\omega_i|x) &= \frac{p(x|\omega_i) * p(\omega_i)}{p(x)} \\\\
p(x) &= \sum_{i=1}^c p(x|\omega_i) * p(\omega_i) \\\\
 1 &= \sum_{i=1}^cp(\omega_i|x) 
\end{aligned}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Posterior = prior * likelihood / evidence</code>, 不过因为使用贝叶斯进行后验估计的时候，evidence使用是相同的，所以不需要考虑这一项，我们只需要聚焦在先验概率和似然的计算上即可。</p>
<p><br></p>
<ul>
<li><strong>Optimal Bayes Decision rules</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这里使用的就是后验概率来进行决策：if $p(\omega_1|x) &gt; p(\omega_2|x)$, decides $\omega_1$, otherwise $\omega_2$. 在此基础上，我们还可以证明，这种决策方式是错误概率最小的一种决策方式，这是因为：</p>
<script type="math/tex; mode=display">
p(error|x) = min(p(\omega_1|x), p(\omega_2|x))</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Special cases:</code>总共是两种特殊情况，当然也是从后验概率计算公式的角度出发进行考虑。</p>
<ul>
<li>if $p(\omega_1) = p(\omega_2)$, then decide by if $p(x|\omega_1) &gt; p(x|\omega_2)$ then $\omega_1$ otherwise $\omega_2$ (Actually is <code>Maximum likelyhood decision</code>).</li>
<li>if $p(x|\omega_1) = p(x|\omega_2)$, then decide by if $p(\omega_1) &gt; p(\omega_2)$ then $\omega_1$ otherwise $\omega_2$ (Actually is <code>Prior</code>).</li>
</ul>
<p><br></p>
<ul>
<li><strong>Bayes risks</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在Bayes risks当中引入了action和risk的概念，其中$\lambda(\alpha_i, \omega_j)$表示的是在 $\omega_j$ 类别之上 take $action_i$ 的 $risk$, 所以我们又可以得到一个新的优化目标，就是选取action当中的Bayes risks当中最小的。</p>
<script type="math/tex; mode=display">
\begin{aligned}
R(\alpha_i|x) &= \sum_{j=1}^c\lambda(\alpha_i, \omega_j)p(\omega_j|x) \\\\
R(\alpha_i) &= \sum_{over x}R(\alpha_i|x)
\end{aligned}</script><ul>
<li><strong>Discriminant function</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于在贝叶斯决策当中，我们选取的是后验概率作为我们的决策策略。所以可以得到贝叶斯的Discriminant function:</p>
<script type="math/tex; mode=display">
g(x) = lnp(\omega_i|x) = lnp(x|\omega_i) + lnp(\omega_i)</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以看到这个式子当中，先验从数据当中很容易获取，主要是似然的估计，所以我们需要对似然函数的参数进行估计。最直接而且最朴素的就是假设，数据在类别确定的时候是满足<code>高斯分布或者正态分布</code>，这样我们就能写出似然函数的形式（其中$\Sigma$为协方差矩阵, $\mu$为均值, $| |$为行列式值）：</p>
<script type="math/tex; mode=display">
p(x|\omega_i) = p(x|\theta) = \frac{1}{(2\pi)^{\frac{d}{2}}|\Sigma|^{\frac{1}{2}}} e^{-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)}</script><p><br></p>
<ul>
<li><strong>MLE and Bayesian Estimation</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来一个很自然的问题就是，既然窝已经知道了似然函数的形式，那我的参数应该怎么去估计呢？别急，这里给出了两种用来估计最佳参数的方法，一种是Maximum Likelyhood Estimation, 也就是我们常说的极大似然估计，还有一种Bayesian Estimation这里就不太涉及，主要思想是提前假设参数本身也是符合一定的分布的，而在MLE当中参数是有一个最优的值，需要通过数据去估计这个最优的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来我们来看看MLE是如何估计参数，顾名思义，需要去最大化数据集的似然。这里我们定义$p(D|\omega_i)$为数据集的似然函数，并且假设数据$x_1, x_2, … i.i.d$是独立同分布的数据，那么我们的数据集似然就能表示为所有数据的似然连乘，然后取一个对数似然变为连加，所以最后的log-likelyhood可以表示为如下的形式，然后我们只需要<code>maximize</code>这个似然函数即可：</p>
<script type="math/tex; mode=display">
l(\theta) = lnp(D|\theta) = \sum_{i=1}^nlnp(x_i|\theta)</script><script type="math/tex; mode=display">
\theta^* = argmaxl(\theta) \implies \nabla_{\theta}l(\theta) = 0</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后分别对$\mu$和$\Sigma$进行求导，然后取最大值即可，详细的推导过程可以参考我在<a href="https://github.com/MySuperSoul/DM/blob/master/assignment/hw1/hw1_3160104367_%E9%BB%84%E4%BA%A6%E9%9D%9E.pdf" target="_blank" rel="noopener">DM-assignment1</a>当中的推导过程，采用的就是对矩阵进行求导，然后取极值的方式。So far, the MLE of all parameters for class k is shown below:</p>
<script type="math/tex; mode=display">
\begin{cases}
\hat{\mu_k} = \frac{1}{m} \sum_{i=1}^mx_i \\\\
\hat{\Sigma_k} = \frac{1}{m}\sum_{i=1}^m(x_i-\hat{\mu_k})(x_i-\hat{\mu_k})^T \\\\
\hat{\phi_k} = \frac{N_k}{N}
\end{cases}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不过在这里有一点是需要注意的是，我们可以看到协方差矩阵还可以写成这种形式，$\Sigma = \frac{1}{k}XX^T$, 所以<strong>当featrues数大于samples数</strong>的时候，矩阵$\Sigma$是不满秩矩阵，也就意味着这个时候是不能通过MLE来估计参数的，因为$|\Sigma| = 0$, 这个时候log-似然♾。</p>
<p><br></p>
<ul>
<li><strong>Back to discriminat function</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在之前我们讨论了如何利用MLE来估计似然函数的参数，在这里我们主要讨论几种discriminat function的形式，也就是$g(x)$函数的线性关系。我们首先将$p(x|\omega_i)$的高斯形式带入上面的log似然函数，得到：</p>
<script type="math/tex; mode=display">
g(x) = -\frac{1}{2}(x_i-\mu)^T\Sigma^{-1}(x_i-\mu)-\frac{d}{2}ln2\pi-\frac{1}{2}ln|\Sigma|+lnp(\omega_i)</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>(1)Case $\Sigma_i = \sigma^2I$</strong></p>
<script type="math/tex; mode=display">
g(x)=-\frac{1}{2\sigma^2}(X^TX-2\mu_i^TX+\mu_i^T\mu_i) + lnp(\omega_i) = \omega_i^TX+\omega_{i0} \implies linear</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Hyperplanes</strong>:</p>
<script type="math/tex; mode=display">
\begin{aligned}
g_i(x) = g_j(x)
\end{aligned}</script><script type="math/tex; mode=display">
0 = (\frac{\mu_i-\mu_j}{\sigma^2})^Tx - \frac{\mu_i^T\mu_i - \mu_j^T\mu_j}{2\sigma^2} + ln\frac{p(\omega_i)}{p(\omega_j)}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>(2)Case $\Sigma_i = \Sigma$, 即所有类的cov矩阵是相同的</strong></p>
<script type="math/tex; mode=display">
g_i(x) = \mu_i^T\Sigma^{-1}x-\frac{1}{2}\mu_i^T\Sigma^{-1}\mu_i + lnp(\omega_i) \implies linear</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>(3)Case $\Sigma_i = arbitary$</strong></p>
<script type="math/tex; mode=display">
g_i(x) = x^T\omega_ix+\omega_i^Tx + \omega_{i0} \implies Quadratic</script><p><br></p>
<ul>
<li><strong>Error Probabilities</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这一个part会展示为什么选用后验是一个最优的策略，首先我们看两分类的问题：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>(1)two-classes</strong></p>
<script type="math/tex; mode=display">
\begin{aligned}
p(error) &= p(x\in R_2, \omega_1) + p(x\in R_1, \omega_2) \\\\
&= p(x\in R_2|\omega_1)p(\omega_1) + p(x\in R_1|\omega_2)p(\omega_2) \\\\
&= \int_{x\in R_2}p(x|\omega_1)p(\omega_1) + \int_{x\in R_1}p(x|\omega_2)p(\omega_2)
\end{aligned}</script><p><img src="/2019/06/29/machine-learning-1-DM-and-Bayesian/2.png" alt></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>(2)multi-classes</strong></p>
<script type="math/tex; mode=display">
p(correct) = \sum_{i=1}^c \int_{x\in R_i}p(x|\omega_i)p(\omega_i)</script><p><br></p>
<ul>
<li><strong>Naive Bayes classifier</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 经过前面的一系列铺垫之后，我们引入今天的最后一个主题，<strong>朴素贝叶斯分类器</strong>。思想非常朴素，就是利用的后验来进行决策。而后验正比似然乘上先验，先验知识很容易从数据当中得到，似然则假设的是不同featrues之间是不相关的，也即：</p>
<script type="math/tex; mode=display">
p(\omega_i|x) \propto p(x|\omega_i)p(\omega_i) = p(x_1|\omega_i)p(x_2|\omega_i)...p(x_n|\omega_i)p(\omega_i)</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 到这里之后，我们只需要对每一个featrue进行一个似然的估计就可以了，根据数据的形式分为两种情况：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>1)离散值：</strong> 在$\omega_i$类别当中直接数数量除一下就可以得到似然的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>2)连续值：</strong> 这种情况之下假设$\omega_i$的数据符合高斯分布，分别去计算mean $\mu$ 和方差 $\sigma^2$, 然后用学到的高斯模型对输入的数据进行似然计算即可。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后要提一点就是<code>拉普拉斯平滑</code>，为什么要做平滑呢，因为在离散值的时候，很可能输入的数据在数据集当中是不存在，那么这个时候根据先前的计算公式计算得出该项为0，使得整个连乘的后验概率均为0，显然这是不合理的一种计算方法，所以我们需要进行平滑处理，具体的平滑操作是, 其中的K为$\omega_k$类当中总的类别数目：</p>
<script type="math/tex; mode=display">
p(x_i|\omega_k) = \frac{|x_{ik}|+1}{N_{\omega_k}+K}</script><p><br></p>
<h3 id="3-Summary-for-Naive-Bayes"><a href="#3-Summary-for-Naive-Bayes" class="headerlink" title="3. Summary for Naive Bayes"></a>3. Summary for Naive Bayes</h3><ul>
<li>Robust to isolated noise points</li>
<li>Handle missing values by ignoring the instance during probability estimate calculations</li>
<li>Robust to irrelevant attributes</li>
<li><strong>Independence assumption may not hold for some attributes</strong></li>
</ul>
]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title>python-basic</title>
    <url>/2019/06/23/python-basic/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;最近马上要python考试了，anyway虽然是基础课，还是稍微复习一下，在这里记录一下可能会有的坑和平时作业里面的一些错题，以后依一些其他基本的需要注意的东西都可以写到里面来～</p>
<a id="more"></a>
<h3 id="Slides"><a href="#Slides" class="headerlink" title="Slides"></a>Slides</h3><h4 id="chapter1"><a href="#chapter1" class="headerlink" title="chapter1"></a>chapter1</h4><ul>
<li><p>Unicode码：为每个字符设定了统一的并且是唯一的二进制编码，用来满足跨平台的需求。 <code>\u</code>表示Unicode码。</p>
</li>
<li><p>utf-8编码：每一个ASCII码都有一个对应的utf-8编码，正好与8位的ASCII编码是一样的。py程序默认是utf-8编码格式，并且是<code>不定长</code>的编码方式。</p>
</li>
<li>py是一种解释型的语言。</li>
<li>标识符：由<code>字符</code>，<code>下划线</code>，<code>数字组成</code>，但是注意的是不能以<code>数字开头</code>.<ul>
<li>my_test</li>
<li>_123</li>
</ul>
</li>
</ul>
<h4 id="chapter2"><a href="#chapter2" class="headerlink" title="chapter2"></a>chapter2</h4><ul>
<li>二进制，八进制，十六进制：0b(B)、0o(O)、0x(X)</li>
<li>浮点数 <strong>运算(注意是运算)</strong> 存在误差：<code>2.1-2.0==0.1 False</code>. 并且浮点数的<code>//</code>运算输出也是浮点数。</li>
<li>科学计数法：<code>12345 = 1.23e4, 0.012 = 1.2e-2</code>.</li>
<li>复数：real+imag * j，其中real是实数部分，imag是虚数部分。</li>
<li>函数和方法：<code>方法</code>是依赖数据类型的另一种函数，一般方法是在类当中定义的叫做 *类方法* 。</li>
<li>多行字符串，是用<code>&#39;&#39;&#39;xxx&#39;&#39;&#39;</code>来表示多行字符串。在这种情况下给每一行的字符串自动加上一个<code>\n</code>来进行换行。</li>
<li>python支持多条件比较，也即<code>1&lt;3&lt;5 == 1&lt;3 and 3&lt;5</code>, <code>1&lt;3&gt;2 == 1&lt;3 and 3&gt;2</code>, 所以这两个都是True。</li>
<li>一定要注意and 和 or 判断这两个坑，一个是and如果前面的已经False，后面就不会判断，or前面如果已经True，后面的也不会判断了。</li>
<li>3 and 5, 最后一个表达式的值作为整个表达式的值。</li>
<li>运算的优先级和方向：除掉<code>**</code>的方向是从右往左的，其他所有运算的方向都是从左往右的。</li>
<li>列表运算：加法<code>[1, 2, 3] + [c, py]</code>, 乘法<code>[1] * 3 -&gt; [1, 1, 1]</code></li>
<li>int函数用法：<code>int()-&gt;0, int(&quot;02&quot;), int(&quot;  35 &quot;), int(&quot;35&quot;, 8)表示的是八进制下的&quot;35&quot;代表的10进制数</code>.</li>
<li>其他内置函数：<code>bin(), hex(), oct(), ord(str)-&gt;unicode, chr(unicode)-&gt;str</code></li>
<li>序列不等的赋值：<code>i, *j = &quot;123&quot;, j -&gt; [&#39;2&#39;, &#39;3&#39;]</code></li>
<li>格式化：<code>^, &lt;, &gt;</code>分别代表的是居中、左、右对齐方式。科学计数法：<code>.2e</code>保留两位小数的科学计数法。<code>{index_1:x.yf}{index_2:x.yf}</code>格式化字符串。<code>format(value, &quot;x.yf&quot;)</code></li>
</ul>
<h4 id="chapter3"><a href="#chapter3" class="headerlink" title="chapter3"></a>chapter3</h4><ul>
<li>列表逆序：<code>lst[::-1]</code>。</li>
<li>列表的浅复制：<code>b = a[:]</code>, 这样复制出来的就是两个不同的列表。或者采用列表当中的方法：<code>b = a.copy()</code>.</li>
<li>原始字符串：<code>r&#39;hello\n&#39; -&gt; hello\n</code>, 字符串<code>不可修改</code>, <code>find(str, start_pos, end_pos)</code></li>
<li><code>title()首字母大写，lower(), upper()</code></li>
<li>字符串的format函数：<code>{index:&lt;填充&gt;|^, &gt;, &lt;| &lt;宽度.精度&gt;&lt;格式&gt;}</code>, 同时<code>&#39;{:,}&#39;.format表示的是千分位数用逗号隔开的形式</code></li>
<li>列表方法：<code>l.extend(x), l.pop(index)默认最后一个且会返回, l.remove(value), l.reverse(), l.sort(), l.insert(index, value)若index超则最后一个, 如果是index为负数的时候超则都是插入在第一个</code>.</li>
<li>a = (3) -&gt; int, a = (3,) -&gt; tuple, 并且元组只有<code>count(x) 和 index(x)这两个函数</code></li>
<li>需要注意split函数：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">sen = <span class="string">'hello    wor   ld  '</span></span><br><span class="line">s = sen.split()</span><br><span class="line">print(len(s)) -&gt; 3</span><br><span class="line"></span><br><span class="line">s = sen.split(<span class="string">' '</span>)</span><br><span class="line">print(len(s)) -&gt; 10</span><br></pre></td></tr></table></figure>
<ul>
<li><p>随机函数库：random库</p>
<ul>
<li>random.random() -&gt; [0.0, 1.0)</li>
<li>random.uniform(a, b) -&gt; [a, b]</li>
<li>random.randint(a, b) -&gt; 随机的一个整数</li>
</ul>
</li>
</ul>
<p><img src="/2019/06/23/python-basic/random.png" alt="random"></p>
<h4 id="chapter4"><a href="#chapter4" class="headerlink" title="chapter4"></a>chapter4</h4><ul>
<li><p>Python map函数: <strong>map(function, iterable)</strong> 对指定的序列执行<code>map</code>操作，也即每个元素都执行function, <code>x, y = map(int, input().split())</code>执行的是内置函数<code>int</code>, 或者也可以是匿名函数<code>map(lambda x : x**2, [1, 2, 3])</code>.</p>
</li>
<li><p>try-except使用格式：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    block</span><br><span class="line"><span class="keyword">except</span> Exception <span class="number">1</span>:</span><br><span class="line">    block1</span><br><span class="line"><span class="keyword">except</span> Exception <span class="number">2</span>:</span><br><span class="line">    block2</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    block3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    block4</span><br><span class="line"><span class="keyword">finally</span>: block5</span><br></pre></td></tr></table></figure>
<ul>
<li>while使用格式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition):</span><br><span class="line">    block1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    block2</span><br></pre></td></tr></table></figure>
<ul>
<li>Gcd算法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b)</span><br></pre></td></tr></table></figure>
<h4 id="chapter5"><a href="#chapter5" class="headerlink" title="chapter5"></a>chapter5</h4><ul>
<li>set是一种容器，<code>没有先后顺序，并且元素的值不重复</code>, 需要注意的是集合的元素需要是<strong>不可变对象</strong>, 换句话说就是列表不能成为集合当中的元素.</li>
<li>空集合：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">empty = set()</span><br><span class="line">empty = &#123;&#125; <span class="comment">#创建的是空字典</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法：<code>add, remove, len, max, min, sum, issubset, issuperset</code>, 需要牢记的是集合是<code>无序的</code>，所以每次print出来的结果是不确定的。</li>
<li>在集合当中的 <code>==</code> 判断的是两个set当中的元素是否是相同的，如果是相同的则输出的是<code>True</code>.</li>
<li><code>&lt;, &lt;=, &gt;, &gt;=</code>判断是真子集，子集，真超集，超集这些的。</li>
<li>集合运算<code>|, &amp;, -, ^</code>分别是<code>并集、交集、差集、对称差</code>，对称差指的是除了共同元素之外的元素，也就是<code>a ^ b = (a | b) - (a &amp; b)</code></li>
<li>列表去重并且顺序不变两种方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">addr_to = list(set(a))</span><br><span class="line">addr_to.sort(key=a.index)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">addr_to = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> addr_to:</span><br><span class="line">        addr_to.append(i)</span><br></pre></td></tr></table></figure>
<ul>
<li>字典的创建方式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fac = dict([(key1, value1), (key2, value2)])</span><br><span class="line">fac = dict(key1=value1, key2=value2) <span class="comment">#这种方式需要使用标识符，并且键用的是str类型</span></span><br><span class="line"><span class="comment"># -&gt; &#123;'key1':value1, 'key2':value2&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字典的键必须要是不可变对象，可变对象比如<code>列表，字典</code>是不能作为字典的键的。</li>
<li>字典的方法：<code>in, not in</code>判断的是一个值是否存在字典的键当中。get(key, 默认值)这个函数可以在后面设置一个默认值作为不存在时候的返回，不加是<code>None</code>.</li>
</ul>
<p><img src="/2019/06/23/python-basic/dict_function.png" alt="dict functions"></p>
<h4 id="chapter6"><a href="#chapter6" class="headerlink" title="chapter6"></a>chapter6</h4><ul>
<li>lambda表达式：<code>g = lambda x, y, z : x + y + z -&gt; g(1, 2, 3)</code></li>
<li>位置参数: 就是普通的那种参数传递方式</li>
<li>关键字参数(可以允许位置不同时进行赋值)：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(x1,y1,x2,y2)</span>:</span> <span class="comment">#求平面上两点距离 </span></span><br><span class="line">    print(<span class="string">"x1=&#123;&#125;,y1=&#123;&#125;,x2=&#123;&#125;,y2=&#123;&#125;"</span>.format(x1,y1,x2,y2)) </span><br><span class="line">    <span class="keyword">return</span> sqrt((x1-x2)**<span class="number">2</span>+(y1-y2)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(dis(x1=<span class="number">1</span>,y2=<span class="number">5</span>,y1=<span class="number">3</span>,x2=<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>位置参数与关键字参数一起使用：需要注意⚠️的是这种情况之下，位置参数需要先写，然后再使用关键字参数，否则会出错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#correct use</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(x1,y1,x2,y2)</span>:</span> <span class="comment">#求平 面上两点距离     </span></span><br><span class="line">     print(<span class="string">"x1=&#123;&#125;,y1=&#123;&#125;,x2=&#123;&#125;,y2=&#123;&#125;"</span>.format(x1,y1,x2,y2)) </span><br><span class="line">     <span class="keyword">return</span> sqrt((x1-x2)**<span class="number">2</span>+(y1-y2)**<span class="number">2</span>)</span><br><span class="line">print(dis(<span class="number">1</span>,<span class="number">3</span>,y2=<span class="number">5</span>,x2=<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#wrong case</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(x1,y1,x2,y2)</span>:</span> <span class="comment">#求平面上两点距离  </span></span><br><span class="line">    print(<span class="string">"x1=&#123;&#125;,y1=&#123;&#125;,x2=&#123;&#125;,y2=&#123;&#125;"</span>.format(x1,y1,x2,y2)) </span><br><span class="line">    <span class="keyword">return</span> sqrt((x1-x2)**<span class="number">2</span>+(y1-y2)**<span class="number">2</span>)</span><br><span class="line">print(dis(<span class="number">1</span>,y1=<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>默认值参数：这里就是需要注意的是，默认值参数在函数对象被创建的时候同时被创建，相当于如果默认值有一个<code>list</code>的时候，有一个静态的<code>static</code>的list一直存在：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(arg, result=[])</span>:</span></span><br><span class="line">     result.append(arg)</span><br><span class="line">print(result)</span><br><span class="line">init(<span class="string">'a'</span>) <span class="comment">#['a']</span></span><br><span class="line">init(<span class="string">'b'</span>) <span class="comment">#['a', 'b']</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不定长数目参数：使用<code>*</code>将可变的参数<strong>变为元组存放</strong>，具体的使用🌰：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countnum</span><span class="params">(a,*b)</span>:</span> <span class="comment">#计算参数个数</span></span><br><span class="line">    print(b) <span class="comment">#(7, 9)</span></span><br><span class="line">    print(len(b)+<span class="number">1</span>) <span class="comment"># 3</span></span><br><span class="line">countnum(<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">countnum(<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">89</span>)</span><br></pre></td></tr></table></figure>
<p><code>*</code>或者是<code>**</code>作用在函数的形参上代表的分别是用<code>元组</code>和<code>字典</code>来接收参数。<br><code>*</code>或者是<code>**</code>作用在实参上代表的是解包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(*lst) <span class="comment"># 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countnum</span><span class="params">(a,**d)</span>:</span> <span class="comment">#计算参数个数</span></span><br><span class="line">    print(d)</span><br><span class="line">    print(len(d)+<span class="number">1</span>)</span><br><span class="line">countnum(<span class="number">3</span>,x1=<span class="number">9</span>,x2=<span class="number">1</span>,x3=<span class="number">6</span>,x4=<span class="number">89</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>return</code>如果没有则默认值是<code>None</code></li>
<li><p>命名空间：全局变量和局部变量不一样，在<code>局部区域</code>里面可以使用<code>全局变量</code>，但是这个时候<code>不能在局部函数内部使用了全局变量再定义同名变量，否则出错❌，会变成变量还未定义就使用</code>。但是一旦定义了同名的变量，使用都是用的局部变量来使用。要使用和修改全局变量，请使用<code>global</code>关键字来完成。</p>
</li>
<li><p>内置函数<code>zip</code>用来打包📦两个可迭代的序列</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">print(list(zip(a, b)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典的键值对互换</span></span><br><span class="line">dic = &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">2</span>, <span class="string">'1'</span>:<span class="number">500</span>&#125;</span><br><span class="line">print(dict(zip(dic.values(), dic.keys())))</span><br><span class="line"><span class="comment"># &#123;1: 1, 2: 2, 500: '1'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eval 计算表达式的值</span></span><br><span class="line">a = <span class="number">3</span>; b = <span class="number">7</span></span><br><span class="line">print(eval(<span class="string">'a * 3 + b * 5'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># exec 执行python语句</span></span><br><span class="line">exec(<span class="string">'print("hello world")'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">all, any 接受的是可迭代的序列</span></span><br><span class="line"><span class="string">all表示全部是True，才返回True</span></span><br><span class="line"><span class="string">any表示只要有一个True，即结果最后返回的是True</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">all([[], <span class="literal">False</span>, <span class="number">0</span>]) <span class="comment"># False</span></span><br><span class="line">all([<span class="number">1</span>, <span class="literal">True</span>, [<span class="number">1</span>]]) <span class="comment"># True</span></span><br><span class="line">any([[], <span class="literal">False</span>, <span class="number">0</span>]) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __main__的作用域就是全局域</span></span><br></pre></td></tr></table></figure>
<ul>
<li>命令行参数格式：sys.argv[0]文件名，sys.argv[1]…都是参数。</li>
<li>python包：是一个目录，当中要包含<code>init.py</code>，然后就是那种传统的包，可以进行<code>import package.module</code></li>
</ul>
<h4 id="chapter7"><a href="#chapter7" class="headerlink" title="chapter7"></a>chapter7</h4><ul>
<li>文件打开：<code>open(filename, mode)</code></li>
</ul>
<p><img src="/2019/06/23/python-basic/file_mode.png" alt="file mode"></p>
<ul>
<li><p>读写函数：</p>
<ul>
<li>read: 将文件所有内容读取</li>
<li>readlines: 按行读取内容，但是列表当中的每一项最后都有一个<code>\n</code>, readline也是一样的会有一个<code>\n</code>在读取的字符串最后。</li>
</ul>
</li>
<li><p>多条件排序：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans=sorted(counts.items(), key=<span class="keyword">lambda</span> x:(-x[<span class="number">1</span>], x[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># 按照value降序，然后再按照key升序排列</span></span><br></pre></td></tr></table></figure>
<h4 id="chapter8"><a href="#chapter8" class="headerlink" title="chapter8"></a>chapter8</h4><ul>
<li><p>一切内容皆是对象，函数和类也是对象。</p>
</li>
<li><p>类主要指的是类型，对象是比较具体的一些值。lst = [1, 2, 3], 其中list是对象lst的class，也就是list类型的对象</p>
</li>
<li><p>类有自己的名字空间，同时每个对象也有自己的名字空间。</p>
</li>
<li><p>构造方法：<code>def __init__(self, …)</code> 构造方法，当对象被构造的时候被自动调用，可以声明类所产生的对象属性，并可为其赋初始值，最重要的是这个函数是<strong>不能有返回值</strong>的。-&gt; 创建对象的时候调用的是<code>object</code>本身的<code>__init__</code>方法。</p>
</li>
<li><p>self参数：必须为第一个形参，代表的是将来要创建的对象本身。在类的方法当中访问数据成员的时候，需要使用self.parameter进行调用。在外部通过对象调用实例方法的时候不需要传递self参数，如果在外部通过类来调用实例方法的时候，可以显式的把对象传到self里面。</p>
</li>
<li><p>python社团规定：</p>
<ul>
<li>_xxx 内部名，不应该在外部使用</li>
<li><code>__xxx</code> py解释器会自动换名为<code>_class__xxx</code>，需要注意的是成员变量和类变量都会自动换名，所以对象是直接访问不到这个变量的.但是需要注意的是，可以使用<code>object._class__xxx</code>访问到该变量，所以并不是绝对意义上的私有变量。</li>
<li><code>__xxx__</code>系统定义的特殊成员，一般不使用这种标识符。</li>
<li>类变量和实例变量都是可以<code>动态增加对应的变量的</code>.</li>
</ul>
</li>
<li><p>继承的类如果重写了<code>__init__</code>, 如果要初始化父类需要显式的<code>super().__init__</code>调用父类的初始化函数。</p>
</li>
<li><p>python多态，一般是通过重写<code>__add__, __len__, __sub__</code>之类的函数来自定义自己的基本运算。</p>
</li>
</ul>
<hr>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol>
<li><p>python当中浮点数是<code>float</code>类型，并没有<code>double</code>型类型。</p>
</li>
<li><p><code>round(x, 2)</code>表示的是保留两位小数的四舍五入法。<code>round(18.67, 1) = 18.7, round(18.67, -1) = 20.0, round(18.67, 0) = 19.0, floor(), ceil(), int(&quot;20&quot;, 16) = 32</code>.</p>
</li>
<li><p>逻辑值<code>not, or, and</code>如果有多个则是一步一步的判断过去的。从左到右的direction, 就是说or或者and左右两边都要是一个表达式.</p>
</li>
<li><p><code>math.sin(x)</code>其中x是弧度制表示的，所以用角度值需要进行相对应的制度转换.</p>
</li>
<li><p><code>0 and anything</code>的结果都是0，其他的<code>value1 and value2</code>结果表达式都是value2.</p>
</li>
<li><p><code>list</code>只有<code>index</code>方法，对于字符串而言是有<code>index</code>和<code>find</code>两种方法的。其中<code>find</code>没找到是返回<code>-1</code>, <code>index</code>没找到的话直接是报错。</p>
</li>
<li><p>list的<code>pop(index)</code>按照index，默认是pop列表的最后一个值。<code>remove(value)</code>是按照value来remove的.</p>
</li>
<li><p>浮点数的相等是看内部的浮点数表示，所以如果两个变量引用同一个常量浮点数的话，相等是True，因为本身就是同一个常量引用<code>x = 2.0;y=2.0 (x==y) = True</code>. 但是如果涉及到浮点数的运算的时候需要特别注意，一般来说表示方式就有变化，所以很大概率并不是一个值了。并且<code>低精度在和高精度比较的时候，会自动转换到高精度</code>.</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">2</span>;y=<span class="number">2.0</span>   <span class="comment">#分号可把两个语句写在一行</span></span><br><span class="line"><span class="keyword">if</span>(x == y):</span><br><span class="line">   print(<span class="string">"相等"</span>) <span class="comment"># correct answer</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">"不相等"</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>双重循环list的🌰：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l3=[[(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>)]</span><br><span class="line">print(l3[<span class="number">2</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中j负责外层的创建新列表，i负责内层和j一同生成元组值，</span></span><br><span class="line"><span class="comment"># [[(1, 1), (2, 1)...], [(1, 2), (2, 2)...]]</span></span><br><span class="line"><span class="comment"># 然后根据对应关系来找值即可</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>以只写模式</code>打开的文件不能进行写操作，但是以<code>写模式</code>打开的文件有可能可以进行写操作。</p>
</li>
<li><p>在python当中<code>变量不需事先声明就可使用。</code></p>
</li>
<li><p>注意判断条件：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> number%<span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> number%<span class="number">3</span>:</span><br><span class="line"><span class="comment"># 代表的是number不是2的倍数，但是是3的倍数</span></span><br><span class="line"></span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b[<span class="number">2</span>]=b</span><br><span class="line"><span class="comment"># 这种情况下是无限循环的情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v &lt; values[row][column]:</span><br><span class="line">    v = values[row][column]</span><br><span class="line"><span class="comment"># 注意求的是最大值，而不是最小值</span></span><br></pre></td></tr></table></figure>
<ol>
<li>🐒经典题：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input().strip())</span><br><span class="line">ls = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line">index = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(ls) &gt; <span class="number">1</span>:</span><br><span class="line">    index = (index + <span class="number">3</span>) % len(ls)</span><br><span class="line">    <span class="keyword">del</span> ls[index]</span><br><span class="line">    index -= <span class="number">1</span> <span class="comment"># 注意这里要把index-1</span></span><br><span class="line"></span><br><span class="line">print(ls[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在三引号的字符串中可以包含单引号，双引号字符. 不过在单独的单双引号的时候，需要考虑转义或者单引号利用双引号这种不同的表示形式。</p>
</li>
<li><p>注意在多变量赋值的时候,<code>x = y = z + 1</code>是不会出错的，但是<code>x = (y = z + 1)</code>是出错的，因为python自动将<code>y = z + 1</code>作为一个表达式处理，但是又没有返回值，所以出错！！</p>
</li>
<li><p>list的<code>sort</code>方法是没有返回值的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>basis</tag>
      </tags>
  </entry>
  <entry>
    <title>Old Books Trading Website</title>
    <url>/2019/06/22/Website/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;陆陆续续写了大概两周时间的旧书交易网站终于快写完啦！！BS课程的课程项目设计，真是心力交瘁。刚好新搞了一个博客试试水，就在这里记录一些开发过程当中的感想和碰到的很多很多坑吧orz，不过还是学到很多东西的吖！<br><a id="more"></a></p>
<h3 id="后端框架"><a href="#后端框架" class="headerlink" title="后端框架"></a>后端框架</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;后端框架选用的是<code>Django</code>框架开发的，为什么选<code>Python</code>作为后端的语言呢，一方面是这学期刚好也有在上python课程，另一方面python真的很友好啊，不过以后也要尝试用<code>java spring</code>做点小项目。</p>
<h4 id="Django路由"><a href="#Django路由" class="headerlink" title="Django路由"></a>Django路由</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>Django</code>框架遵循的是<code>MVC</code>的思想进行开发的框架。<code>urls.py</code>当中是网站路由的配置，一般项目的路由当中是划定不同app下的起始路由，然后在不同的app下再定义各自的url，使得整个项目的路由管理比较独立，比如在我项目当中的总路由配置(BookTradeWeb/urls.py):<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r'^password-reset/'</span>, include(<span class="string">'password_reset.urls'</span>)),</span><br><span class="line">    url(<span class="string">r'^auth/'</span>, include(<span class="string">'useraction.urls'</span>)),</span><br><span class="line">    url(<span class="string">r'^books/'</span>, include(<span class="string">'books.urls'</span>)),</span><br><span class="line">    url(<span class="string">r'^chatting/'</span>, include(<span class="string">'chatting.urls'</span>)),</span><br><span class="line">    url(<span class="string">r'^media/(?P&lt;path&gt;.*)$'</span>, serve, &#123;<span class="string">'document_root'</span>: settings.MEDIA_ROOT&#125;),</span><br><span class="line">    url(<span class="string">r'^$'</span>, TemplateView.as_view(template_name=<span class="string">"login.html"</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;然后在每个单独的app里面可以自定义自己的路由了，以我其中一个app(useraction)下的urls.py为🌰，不过需要记住的是通过<code>python manage.py startapp</code> 创建之后的urls.py是需要自己创建的。在不同的app里面可以定义自己的<code>app_name</code>，在后面写模板语言的时候非常爽的，后面在前端那里再详细写：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app_name = <span class="string">'useraction'</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^login/$'</span>, views.UserLoginView.as_view(), name=<span class="string">'login'</span>),</span><br><span class="line">    url(<span class="string">r'^register/$'</span>, views.UserRegisterView.as_view(), name=<span class="string">'register'</span>),</span><br><span class="line">    url(<span class="string">r'^logout/$'</span>, views.UserLogoutView.as_view(), name=<span class="string">'logout'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="Django-Views"><a href="#Django-Views" class="headerlink" title="Django Views"></a>Django Views</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Django views可以说是很强大了，在<code>MVC</code>架构当中它可以充当view和controller两部分的角色。现在很流行使用<code>restful</code>的方式开发网站。也即后端只提供数据，用<code>json</code>或者<code>protobuf</code>或者其他的数据组织形式来传输数据，而前端向后端发送请求来请求数据或者处理逻辑，实现<code>前后端分离</code>的开发。<br>&nbsp;&nbsp;&nbsp;&nbsp;Django views因为有很多Django自己的加持，使得这两种模式都支持，比如<code>JsonResponse</code>返回json格式的数据，或者通过<code>render(request, index.html, data)</code>的方式直接返回网页，并且能用非常爽的模板语言，简直人见人爱啊有木有！<br>&nbsp;&nbsp;&nbsp;&nbsp;这里我选择的是用的<code>class-based view</code>的方式来写views.py的，在<code>BookTradeWeb/utils.py</code>当中定义了<code>BaseView</code>，这个类继承了Django当中内置的view，后面我们自己的view只需要继承BaseView即可，我们看看BaseView里面定义了些啥：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseView</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        self.request = request</span><br><span class="line">        request.data = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">            request.data = request.GET.dict()</span><br><span class="line">        <span class="keyword">elif</span> request.content_type == <span class="string">'application/json'</span>:</span><br><span class="line">            request.data = request.body.replace(<span class="string">b"'"</span>, <span class="string">b'"'</span>)</span><br><span class="line">            request.data = json.loads(request.data)</span><br><span class="line">        <span class="keyword">elif</span> request.content_type == <span class="string">'multipart/form-data'</span>:</span><br><span class="line">            request.data = request.POST.dict()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> request.FILES == <span class="literal">None</span>:</span><br><span class="line">                request.data[<span class="string">'file'</span>] = request.FILES[<span class="string">'file'</span>]</span><br><span class="line">        <span class="keyword">elif</span> request.content_type == <span class="string">'application/x-www-form-urlencoded'</span>:</span><br><span class="line">            request.data = request.POST.dict()</span><br><span class="line">        <span class="keyword">return</span> self.do_dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_dispatch</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        handler = getattr(self, self.request.method.lower(), <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> callable(handler):</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(make_errors(<span class="string">f"http method <span class="subst">&#123;self.request.method.lower()&#125;</span> not allowed "</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = handler(*args, **kwargs)</span><br><span class="line">                <span class="keyword">if</span> data == <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> JsonResponse(make_success(<span class="string">'success'</span>))</span><br><span class="line">                <span class="keyword">elif</span> self.request.method == <span class="string">'GET'</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(data, dict):</span><br><span class="line">                    <span class="keyword">return</span> data</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">'data'</span>: data, <span class="string">'code'</span>: <span class="number">0</span>&#125;)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                traceback.print_exc()</span><br><span class="line">                <span class="keyword">return</span> JsonResponse(make_errors(str(e)))</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这样定义BaseView有什么好处呢，首先在BaseView里面重写了View当中的<code>dispatch</code>方法，每当有一个请求到达对应路由那里的时候，都会调用dispatch方法。在dispatch当中我们将数据统一都放到<code>request.data</code>里面，后面的views当中无论是<code>POST</code>还是<code>GET</code>都可以在request.data里面拿到数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;其次在do_dispatch当中会去自定义view里面找对应request method的处理方法，也就是说，我们的自定义view里面只需要去写对应的函数，比如说<code>def get(self, request)</code> 处理get请求，<code>def post(self, request)</code>来处理对应的post请求，是不是很方便呢！在自定义view写完之后，只需要在urls.py里面去注册一下就好了，下面举一个🌰：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoginView</span><span class="params">(BaseView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        user = authenticate(username = request.data.get(<span class="string">'username'</span>),</span><br><span class="line">                            password = request.data.get(<span class="string">'password'</span>))</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">and</span> user.is_active:</span><br><span class="line">            login(request, user)</span><br><span class="line">            <span class="keyword">return</span> user.to_dict()</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> user:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'用户名或密码错误！'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'login.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">useraction/urls.py</span><br><span class="line">url(<span class="string">r'^login/$'</span>, views.UserLoginView.as_view(), name=<span class="string">'login'</span>)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="Django-models"><a href="#Django-models" class="headerlink" title="Django models"></a>Django models</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Django提供了一套非常完备的<code>ORM</code>，以至于我真的一行SQL语句都没写啊😂。models也就是数据库里面的表，通过类定义的方式来定义每一张表当中的数据项、属性、外键约束等等。一般定义好models之后只需要执行<code>python manage.py makemigrations &amp;&amp; python manage.py migrate</code>将models迁移到数据库当中。Django项目初始默认使用的数据库是<code>sqlite</code>，我这里将它改成了<code>MySQL</code>，具体就是修改setting.py里面的配置就好了。<br>&nbsp;&nbsp;&nbsp;&nbsp;ORM的语法网上教程或者是<a href="https://docs.djangoproject.com/zh-hans/2.2/" target="_blank" rel="noopener">Django官网教程</a>都有很多的。主要就是内部用的一个<code>QuerySet</code>类来代表返回结果，还有很多奇奇怪怪的用法这里就不再赘述。</p>
<p><br></p>
<h4 id="Django-setting"><a href="#Django-setting" class="headerlink" title="Django setting"></a>Django setting</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Django 通过在项目目录下的setting.py下面进行整个项目的配置，大概讲解一下这些配置是干啥的，就讲一些主要的，其他的都是很容易<a href="http://www.google.com" target="_blank" rel="noopener">Google</a>到的：</p>
<ul>
<li><strong>ALLOWED_HOSTS</strong>: 允许那些host访问，如果需要允许所有一般设置为[‘*’, ]</li>
<li><strong>INSTALLED_APPS</strong>: 这个配置是比较重要的一部分，用来注册项目里面的app，如果你新建的app没有在这里注册的话，项目是找不到你的app里面的方法的，所以我们每次新建都需要在这里进行注册之后才能正常的工作哦😯</li>
<li><strong>Middleware</strong>: 这里是项目中使用的中间件的配置，比如Django内置的用户认证中间价，防跨站攻击的csrftoken中间价等等，如果使用其他的开源中间价都需要在这里进行注册。</li>
<li><strong>TEMPLATES</strong>: 这里主要是存放的静态文件的意思，基本不用去改，Django会去项目所有的templates文件夹下面找对应的模板文件。</li>
<li><strong>DATABASES</strong>: 顾名思义就是数据库的配置了，你想用哪个数据改改这个就好了。</li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">  STATICFILES_DIRS = [</span><br><span class="line">      os.path.join(BASE_DIR, <span class="string">'BookTradeWeb/static'</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  MEDIA_URL = <span class="string">'/media/'</span></span><br><span class="line">  MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'media/'</span>)</span><br></pre></td></tr></table></figure>
这两个是静态文件和资源文件的存放位置，Django会去static和media文件夹里面自动寻找。</li>
</ul>
<hr>
<h3 id="前端模板"><a href="#前端模板" class="headerlink" title="前端模板"></a>前端模板</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前端还是主要用的传统的<code>html+js+css</code>的格式，然后通过<code>ajax</code>向后端发起请求，没能用现在很流行的React或者是Vue有点可惜，只能感慨<code>前端太难了！！</code>.不过Django自己的模板语言用起来还是可以的，不过我感觉这个项目调前端的时间是最主要的啊orz.</p>
<h4 id="静态文件加载"><a href="#静态文件加载" class="headerlink" title="静态文件加载"></a>静态文件加载</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;之前我们在setting里面配置好了static文件目录之后，在模板里面我们可以这样引入，在最开头通过<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125; 加载静态文件</span><br><span class="line">&#123;% static <span class="string">'images/favicon.png'</span> %&#125; 引入对应文件</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;注意Django会搜索所有的static文件夹下的文件，所以一般使用app名称作为前缀来进行区分。</p>
<h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在之前我们提到每个urls.py里面我们可以添加一个<code>app_name</code>字段，并且每个url_pattern里面都可以带上一个<code>name</code>字段，然后在前端就可以直接用模板语言当中的<code>url &#39;app_name:name&#39;</code>来获取后端定义好的路由，这样就算你后端改了路由之后，前端根本不用管啊是不是～<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">useraction/urls.py</span><br><span class="line">app_name = <span class="string">'useraction'</span></span><br><span class="line">url(<span class="string">r'^register/$'</span>, views.UserRegisterView.as_view(),name=<span class="string">'register'</span>)</span><br><span class="line"></span><br><span class="line">template:</span><br><span class="line">&#123;% url <span class="string">'useraction:register'</span> %&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="前端数据渲染"><a href="#前端数据渲染" class="headerlink" title="前端数据渲染"></a>前端数据渲染</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;有两种方式，一种是通过ajax向后端请求，然后用js来进行数据渲染，还有一种是通过模板语言，在<code>render</code>方法的时候将数据传递到模板里面，然后使用模板语言渲染，常用的有：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; data &#125;&#125; 取出传递进来数据当中的data字段</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> ... %&#125;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">&#123;% endif %&#125; 模板语言当中的<span class="keyword">if</span>语句</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">for</span> book <span class="keyword">in</span> books %&#125;</span><br><span class="line">&#123;&#123; book.data &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125; 模板语言当中的<span class="keyword">for</span>语句</span><br><span class="line"></span><br><span class="line">&#123;&#123; book.time|data:<span class="string">"Y-M-d"</span> &#125;&#125; 模板语言当中的filter过滤器</span><br><span class="line"></span><br><span class="line">&#123;&#123; request.user &#125;&#125; 模板当中获取当前请求的user</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;还有很多其他的用法大家自己网上找找也能找到。这里主要将还可以自定义自己的filter，一个很直观的需求就是我像模板里面传进了一个字典，窝怎么根据键来找值呢，Django提供了自定义filter的功能，在app目录下面新建一个<code>templatetags</code>文件夹，首先新建一个<code>__init__.py</code>为空不要紧，但是一定要有。然后建一个自定义的filter文件，这里我是<code>books_filter.py</code>，通过<code>@register.filter</code>标注为一个自定义的filter，然后就写你想要的filter逻辑即可：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template.defaulttags <span class="keyword">import</span> register</span><br><span class="line"><span class="keyword">from</span> BookTradeWeb.utils <span class="keyword">import</span> Category</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Book</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.filter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetDictValue</span><span class="params">(dictionary, key)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(dictionary, dict)</span><br><span class="line">    <span class="keyword">return</span> dictionary.get(key)</span><br><span class="line"></span><br><span class="line">模板中使用：</span><br><span class="line">首先最上方引入你的filter &#123;% load books_filter %&#125;</span><br><span class="line">然后用法：&#123;&#123; book_dict|GetDictValue:key &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由于Django本身是不支持websocket的，但是这次要求要集成一个消息系统，所以想到的是<code>websocket</code>这个全双工的协议。Google了一下，可以通过<code>django-channels</code>第三方的package来实现✅，所以直接pip安装就好。<code>channels</code>是用的<code>redis</code>做消息缓存，所以还要<code>pip install channels-redis</code>，这些需要的依赖一般都是写在<code>requirements.txt</code>当中。如果不想在本机安装redis可以通过<code>docker</code>来开启服务，具体就是开一个docker container就好，<code>docker run -d -p 6379:6379 redis:latest</code>, 搞定。<br>&nbsp;&nbsp;&nbsp;&nbsp;在setting里面注册channels这个app，然后添加如下的设置:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ASGI_APPLICATION = <span class="string">"BookTradeWeb.routing.application"</span></span><br><span class="line">CHANNEL_LAYERS = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'channels_redis.core.RedisChannelLayer'</span>,</span><br><span class="line">        <span class="string">'CONFIG'</span>: &#123;</span><br><span class="line">            <span class="string">"hosts"</span>: [(CONFIGS[<span class="string">'REDIS_HOST'</span>], CONFIGS[<span class="string">'REDIS_PORT'</span>])],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;asgi配置主要是用来处理websocket请求的，类似<code>ws://</code>这样的请求Django自己的服务器是处理不了的，所以这里用asgi配置，需要在app目录下面新建一个<code>routing.py</code>用来处理websocket路由。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">项目目录(BookTradeWeb/routing.py)</span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line">    <span class="comment"># (http-&gt;django views is added by default)</span></span><br><span class="line">    <span class="string">'websocket'</span> : AuthMiddlewareStack(</span><br><span class="line">        URLRouter(</span><br><span class="line">            chatting.routing.websocket_urlpatterns</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app目录下(chatting/routing.py)</span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> consumers</span><br><span class="line"></span><br><span class="line">websocket_urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^ws/chat/(?P&lt;room_name&gt;[^/]+)/$'</span>, consumers.ChatConsumer),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;经过这样一通配置，开启<code>python manage.py runserver</code>，看到<code>ASGI/Channels</code>就配置成功了。</p>
<div align="center">
<img src="/2019/06/22/Website/server.png">
</div>


<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在channels当中处理websocket请求的东西叫做consumer，和上面我们提到的view一样，consumer也是可以自定义的，可以继承自<code>AsyncWebsocketConsumer</code>来实现自己的consumer。主要是几个functions重写一下就好了，<code>connect</code>, <code>disconnect</code>, <code>receive</code>，都是字面意思了就不解释了。每一个websocket连接都会给到一个<code>channel</code>给连接的用户。每一个channel都有一个独有的<code>channel_name</code>, 通过<code>self.channel_name</code>即可获取。</p>
<h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Group组的概念，聊天室必备啊。group以group name来进行区分，不同的channel都可以加入到group里面，group当中提供了<code>group_send</code>来进行广播📢，也就是聊天室的那种效果了。</p>
<h4 id="channel-layer"><a href="#channel-layer" class="headerlink" title="channel_layer"></a>channel_layer</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Django-channels当中提供了get_channel_layer()方法来向指定的channel发送消息，具体使用如下，也就是我们要的点对点聊天的功能了：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> AsyncWebsocketConsumer</span><br><span class="line"><span class="keyword">from</span> channels.layers <span class="keyword">import</span> get_channel_layer</span><br><span class="line"><span class="keyword">from</span> channels.db <span class="keyword">import</span> database_sync_to_async</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> useraction.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> chatting.models <span class="keyword">import</span> ChattingMessage</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">channel_layer = get_channel_layer()</span><br><span class="line"><span class="keyword">await</span> channel_layer.send(</span><br><span class="line">    channel_name,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"chat.message"</span>,</span><br><span class="line">        <span class="string">"message"</span> : message,</span><br><span class="line">        <span class="string">"send_side"</span> : send_side,</span><br><span class="line">        <span class="string">"option"</span> : <span class="string">"chat"</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在channels当中，我们的处理方式都是异步的，比如函数定义都是<code>async</code>, 函数使用都是<code>await</code>, 那对数据库操作一般Django都是同步的操作，这样在channels里面运行是没有任何作用的，所以这个时候我们使用注解让数据库的操作变成异步的<code>@database_sync_to_async</code>, 然后对数据库的操作写在一个函数里面，使用🌰：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> channels.db <span class="keyword">import</span> database_sync_to_async</span><br><span class="line"></span><br><span class="line"><span class="meta">@database_sync_to_async</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateNewMessage</span><span class="params">(self, send_side, recv_side, message)</span>:</span></span><br><span class="line">    mess = ChattingMessage.objects.create(</span><br><span class="line">        send_side_id=int(send_side),</span><br><span class="line">        recv_side_id=int(recv_side),</span><br><span class="line">        message=message</span><br><span class="line">    )</span><br><span class="line">    mess.save()</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="部署方法"><a href="#部署方法" class="headerlink" title="部署方法"></a>部署方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这个项目我使用的是docker进行部署，总共是3个container，其中包括<code>mysql</code>, <code>redis</code>, <code>website</code>这三个container，服务端口列表为:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">port</th>
<th style="text-align:center">service</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6379</td>
<td style="text-align:center">redis</td>
</tr>
<tr>
<td style="text-align:center">3000</td>
<td style="text-align:center">mysql</td>
</tr>
<tr>
<td style="text-align:center">8000</td>
<td style="text-align:center">website</td>
</tr>
</tbody>
</table>
</div>
<h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; 我用的是docker-compose来管理docker container之间的连接关系，重要的配置文件窝都写在项目目录下的<code>config.json</code>里面，docker-compose方便进行container之间的连接，并且自动建立不同container之间的network，能让多个container进行互相访问，非常的方便，用的时候是写<code>docker-compose.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:latest</span></span><br><span class="line"><span class="attr">    command:</span> <span class="bullet">--default-authentication-plugin=mysql_native_password</span> <span class="bullet">--character-set-server=utf8</span> <span class="bullet">--collation-server=utf8_general_ci</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3000:3306"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">       MYSQL_DATABASE:</span> <span class="string">'booktrade'</span></span><br><span class="line"><span class="attr">       MYSQL_ROOT_PASSWORD:</span> <span class="string">'your-password'</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">redis:latest</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"6379"</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">./scripts/start_server.sh</span></span><br><span class="line"><span class="attr">    entrypoint:</span> <span class="string">./scripts/docker_entry.sh</span> <span class="string">db</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8000:8000"</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，这里有一个大坑，就是web container在开启的时候，是和其他服务一起开启的，所以在mysql container还没初始化好的时候，web container就开始尝试写数据到数据库里面去了，当然，这样服务器of course crash了，所以在<code>entrypoint</code>这里加了一个脚本去检查，如果没有初始化好就<code>sleep</code>去等，初始化完毕之后再去连接数据库：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/docker_entry.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">postgres_host=<span class="variable">$1</span></span><br><span class="line">postgres_port=<span class="variable">$2</span></span><br><span class="line"><span class="built_in">shift</span> 2</span><br><span class="line">cmd=<span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wait for the postgres docker to be running</span></span><br><span class="line"><span class="keyword">while</span> ! nc <span class="variable">$postgres_host</span> <span class="variable">$postgres_port</span>; <span class="keyword">do</span></span><br><span class="line">  &gt;&amp;2 <span class="built_in">echo</span> <span class="string">"MySQL is unavailable - sleeping"</span></span><br><span class="line">  sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">&gt;&amp;2 <span class="built_in">echo</span> <span class="string">"MySQL is up - executing command"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run the command</span></span><br><span class="line"><span class="built_in">exec</span> <span class="variable">$cmd</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;web项目的<code>Dockerfile</code>主要就是初始化环境，安装一些package的依赖：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> huangyifei &lt;huangyifei0910@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /code</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -qO- git.io/superupdate.sh | bash</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -y install jq netcat-openbsd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> jq <span class="string">'.DB_HOST = "db"'</span> config.json &gt;&gt; tmp.json &amp;&amp; mv tmp.json config.json</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> jq <span class="string">'.REDIS_HOST = "redis"'</span> config.json &gt;&gt; tmp.json &amp;&amp; mv tmp.json config.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在所有这些做完之后，使用<code>docker-compose build</code>构建当前项目，<code>docker-compose up -d</code>进行container的链接和后台运行，因为mysql container的初始化时间比较长，所以开启之后需要等待<code>20-30s</code>然后就可以愉快的访问啦(localhost:8000)～ 窝是将这个步骤写在<code>./scripts/start_docker.sh</code>里面，<code>./scripts/stop_docker</code>是停止所有的服务，并且移除相对应的container，即插即用，是不是很方便！！</p>
<hr>
<h3 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第一次用Django做后端和docker-compose来部署项目还是踩了不少的坑orz，不过Django强大的特性和很多第三方的package加持，做后端的很多功能也是挺方便的。docker主要是这学期开始接触的，我觉得这东西势必会统治虚拟化啊，即插即用，生态也非常的好，用来部署项目省了很多乱七八糟的配置的问题。后面也会考虑去学一学前端的框架，<code>React or Vue</code> anyway, 还有很多需要学习的，任重而道远啊！Make Progress Everyday！</p>
<ul>
<li>项目地址：<a href="https://github.com/MySuperSoul/BookTradeWeb" target="_blank" rel="noopener">BookTradeWeb</a></li>
<li>使用方法：参考README.md当中的部署方法</li>
<li>部署好的网站：<a href="http://94.191.60.198:8000/" target="_blank" rel="noopener">website</a></li>
<li>Author: huangyifei</li>
<li>Email: <a href="mailto:huangyifei0910@gmail.com">huangyifei0910@gmail.com</a></li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>docker-compose</tag>
        <tag>websocket</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>data-processing</title>
    <url>/2019/07/16/data-processing/</url>
    <content><![CDATA[<p>这是本次项目实训课程当中，我所负责的数据后处理模块所实际使用的两种算法。一种是<code>simhash</code>算法，Google在用的海量网页去重的算法，另一种是<code>textrank</code>算法，用于进行关键词提取、文档自动摘要等算法。在这里对这两种算法进行相关的阐述。</p>
<a id="more"></a>
<h4 id="课程论文简述"><a href="#课程论文简述" class="headerlink" title="课程论文简述"></a>课程论文简述</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为在本次实现的搜索引擎项目当中，我主要负责的就是各类数据的获取，以及主要的数据后处理工作。爬虫部分感觉没有什么好讲的，通过<code>scrapy</code>和<code>selenium</code>、<code>requests</code>, 对于一般的网站爬取工作都可以胜任，不过为了应对很多网站的反爬虫策略，我们自己实现的IP池还是有亮点的，不过不是我写的所以我这里就不展开。我觉得比较有特色是数据后处理部分，在得到数据之后必要的工作是需要对数据进行清洗和加工，所以我主要选取了项目当中在用的<code>simhash</code>文本相似度过滤算法和<code>textrank</code>自动摘要算法来写本次的课程论文。</p>
<p><br></p>
<h4 id="文本相似度处理"><a href="#文本相似度处理" class="headerlink" title="文本相似度处理"></a>文本相似度处理</h4><ol>
<li><strong>文本距离</strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在正式介绍文本相似度算法之前，首先我会对几种比较常用的文本距离计算方式进行介绍。因为文本相似度计算的基础还是在于不同文本当中的文本距离是如何定义的，不同的文本距离计算会导致不同的相似度的生成。</p>
<ul>
<li><strong>欧几里得距离</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 欧几里得距离又称<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB" target="_blank" rel="noopener">欧氏距离</a>。是我们实际当中使用非常频繁的一种距离计算方式。在欧氏空间当中，两个点$x=(x_1, x_2, …, x_n), y=(y_1, y_2, …, y_n)$之间的欧氏距离可以表示为:</p>
<script type="math/tex; mode=display">
d(x, y) = \sqrt{\sum_{i=1}^n(x_i - y_i)^2}</script><ul>
<li><strong>曼哈顿距离</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%93%88%E9%A0%93%E8%B7%9D%E9%9B%A2" target="_blank" rel="noopener">曼哈顿距离</a>是用来在欧氏空间标明两个点在标准坐标系上的绝对轴距总和的一种距离度量方式。从几何的角度来看，<code>欧氏距离</code>度量的是两个点的实际距离，<code>曼哈顿距离</code>度量的是两个点的绝对轴之间的距离。例如在直角坐标系当中$x=(x_1, x_2), y=(y_1, y_2)$, 那么两个点之间的曼哈顿距离表示为：</p>
<script type="math/tex; mode=display">
d(x, y) = |x_1-y_1| + |x_2 - y_2|</script><ul>
<li><strong>余弦距离</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://zh.wikipedia.org/wiki/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E6%80%A7" target="_blank" rel="noopener">余弦距离</a> 是通过计算两个向量之间夹角余弦值来衡量两个向量之间相似度的一种常用的方法。我们都知道如果两个向量之间的夹角越小，余弦值就越接近1.所以我们可以通过计算两个向量的余弦夹角来衡量两个向量之间的相似度。给定两个向量$A, B$， 他们余弦距离衡量公式如下：</p>
<script type="math/tex; mode=display">
similarity(A, B) = \cos(A, B) = \frac{\sum_{i=1}^n A_i \cdot B_i}{\sum_{i=1}^n(A_i)^2 \cdot \sum_{i=1}^n(B_i)^2}</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果<code>similarity</code>越接近1，我们认为这两个向量之间的距离越小，也即相似度也就越高。</p>
<ul>
<li><strong>海明距离(Hamming distance)</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB" target="_blank" rel="noopener">海明距离</a>又称<code>Hamming distance</code>. 是在编码领域常用的一种距离度量的方法。而且方法和思想非常的朴素，相信大家之前在<code>计算机网络</code>课程当中已经接触过海明码的概念。海明距离对于二进制的字符串之间的计算，非常简单，就是直接计算所有位上，不同的码字的数量。例如<code>1011101</code>与<code>1001001</code>之间的汉明距离是2. 虽然hamming distance的思路非常简单，但是它在很多领域当中都有着非常重要的作用，在之后我会介绍的，在我们<a href="https://github.com/MySuperSoul/SearchEngine/tree/master/post-processors/common" target="_blank" rel="noopener">搜索引擎项目</a>当中使用的文本相似度算法就是利用了hamming distance来进行计算相似度。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同时因为hamming distance对于0，1字符串的度量有非常快速的算法，之间通过位运算的方式可以快速的求得两个0, 1字符串之间的海明距离，在我们后处理当中，就是利用这种方法能够快速进行hamming distance计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">params:</span></span><br><span class="line"><span class="string">    code_1 -&gt; str: first hamming code</span></span><br><span class="line"><span class="string">    code_2 -&gt; str: second hamming code</span></span><br><span class="line"><span class="string">    hash_bits -&gt; int: number of the length of two hamming code</span></span><br><span class="line"><span class="string">return:</span></span><br><span class="line"><span class="string">    ans -&gt; int: hamming distance of two hamming code</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HammingDistance</span><span class="params">(self, code_1, code_2)</span>:</span></span><br><span class="line">    x = (code_1 ^ code_2) &amp; ((<span class="number">1</span> &lt;&lt; self.hash_bits) - <span class="number">1</span>)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x:</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">        x &amp;= x - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li><strong>海量文本相似度算法Simhash</strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这次的搜索引擎项目当中，数据后处理的首先问题就是如何对收集到的各种信息进行去重。一个最直接的方法就是根据URL使用set进行去重，当然这只是最基本的重复滤重。还有另外一种情况我们也必须要考虑到，也就是存在<code>文章转载或者抄袭</code>的情况，所以我们对于这种情况也必须进行数据的处理和滤重。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一般情况下，如果要计算两篇文档之间的相似度，传统的思路可能是：</p>
<ul>
<li>可以通过将两篇文章进行分词，通过关键词和对应的权重生成特征词向量，然后就能通过我们前面介绍的几种<code>文本距离</code>计算的方法进行距离度量（比如可以计算特征向量之间的欧氏距离，或者是通过余弦距离来度量两个特征词向量之间的相似度）。通过<code>距离的大小</code>来度量两篇文档的相似度。</li>
<li>通过<code>hash</code>的方法，为每一篇文档通过哈希的方法生成一个特定的哈希指纹，然后通过比对生成的哈希指纹对文本的相似度进行计算。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当然这两种方法都存在着很大的弊端，对于第一种方法的话，在海量的数据面前，这个算法所需要耗费的时间是难以想象的，所以这种方法运用到搜索引擎上，理论上在时间的花费成本非常之高。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于第二种方法的话，重点就在于<code>如何设计一个好的hash函数</code>，如果采用传统的hash方法，比如说是<code>md5</code>这种局部不敏感的哈希方法的话，那么在文本有很小的变动时候，生成的md5哈希码的差异也会相差甚远，显然这不是我们需要的hash函数。我们<code>理想的hash函数</code>应该对于相似的文档能够生成比较相似的哈希码，从而我们才能从hash code当中提取文章的相似度。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以接下来就会介绍<strong>Simhash</strong>的算法，用来解决巨大数据量网页去重的算法。该算法最初是Google提出的一种用于网页去重的算法，详细的论文可以参考<a href="https://www2007.org/papers/paper215.pdf" target="_blank" rel="noopener">《detecting near-duplicates for web crawling》</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Simhash</code>是局部不敏感哈希方法当中的一种。也即输入文档的小部分改动对最后生成的hash code并不会有很大的影响。Simhash方法的主要思想是<code>降维思想</code>，通过将高维的特征词向量降维到生成的hashcode维度，一般选取的<code>64bits</code>或者<code>128bits</code>生成hashcode. 然后通过计算不同文档之间simhash值的hamming distance来度量不同文档之间的相似度。具体的simhash算法一般处理为六个步骤：<code>分词 -&gt; hash -&gt; 加权 -&gt; 合并 -&gt; 降维 -&gt; hamming distance</code>.</p>
<ul>
<li><strong>分词</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 分词步骤当中主要是对文档进行分词，并且确定每个分词的权重分布。中文分词我所使用的是<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba</a>进行分词，因为我们项目当中大部分还是收集的中文博客、demo等资源，并且在实际测试的时候发现<code>jieba</code>对于英文的分词效果也还是可以的！其中权重值在后续会使用，代表的是该词语在整篇文章当中的重要性。</p>
<ul>
<li><strong>hash</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hash步骤主要是对上面得到的文档词语进行哈希函数的计算，通常在这里需要指定<code>hash_bits</code>, 也即后续的每篇文档都会降维到<code>hash_bits</code>这个维度上。通过哈希函数处理之后，每个字符串都会变成一个01的字符串，同时长度为我们所希望的<code>hash_bits</code>.</p>
<ul>
<li><strong>加权</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 加权过程需要使用到上述我们得到的权重值，通过对所有得到的hash值乘上对应的权重，得到对应的加权后的新哈希值。其中因为得到的是01字符串，我们规定遇到1就是正值，遇到0就是负值，而后进行计算。举个🌰，比如<code>浙江大学</code>编码为<code>101010</code>, 并且权重为<code>5</code>的话，通过加权之后，得到的新的加权哈希值就为：<code>5 -5 5 -5 5 -5</code>. 其他的分词后的词语类似处理。</p>
<ul>
<li><strong>合并</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过上面<code>加权</code>步骤之后，我们得到了所有分词的加权hash code，之后我们对所有的这些加权hash code进行相加，相加之后得到的加权hash code就做为整篇文档的加权hash code. 再举个🌰，我们得到<code>浙江大学</code>哈希值为<code>5 -5 5 -5 5 -5</code>, 同时我们还得到<code>软件工程</code>这个词的哈希值为<code>4 4 -4 4 -4 4</code>, 那么总的加权的哈希值为<code>9 -1 1 -1 1 -1</code>. 其他的处理流程都是类似的。</p>
<ul>
<li><strong>降维</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 降维步骤就是对上述得到的加权code进行一个简单的<code>Sign</code>计算，也即码值大于0的记为1，其他的记为0，就比如上面得到的那一串加权的hash code，在经过降维处理之后，我们就能得到最后文章生成的01 hash code为：<code>101010</code>.</p>
<ul>
<li><strong>Hamming distance</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在上述的pipelines之后我们得到了整篇文档的hash code，接着只需要对两篇文档的hash code计算hamming distance，就能很快的得到两篇文档之间的相似度。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 整个Simhash算法的流程可以用下面这张图进行展示，很清晰的展示了整个算法的流程和做法：</p>
<div align="center">
<img src="/2019/07/16/data-processing/1.png">
</div>

<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于Simhash算法在实际处理海量数据时候还有很多其他的优化查询方式，比如对最后生成的hash code进行分块查询，建立倒排索引等方式加快在样本数据库当中的搜索查询速度。我们项目当中的数据数量远不及Google上的样本数量，所以并没有进行过多的优化，直接计算hamming code进行判断。在项目的后处理模块当中，我将simhash算法封装为一个类，其中使用了开源项目<a href="http://leons.im/posts/a-python-implementation-of-simhash-algorithm/" target="_blank" rel="noopener">simhash</a>来完成hash code的计算。并且当相似度超过<code>95%</code>的时候，我就认为这两篇文档是非常相似的，需要从我们的数据库当中过滤掉，具体实现可以参考我们搜索引擎项目当中的实现<a href="https://github.com/MySuperSoul/SearchEngine/blob/master/post-processors/common/SimHash.py" target="_blank" rel="noopener">SimHashFilter</a>.</p>
<p><br></p>
<ol>
<li><strong>实际效果测试</strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在实现了simhash算法之后，我对实现的该算法进行了相关测试和性能估计。在项目当中我所用的hash_bits长度为<code>128</code>, 因为实际测试时候使用64bits的hamming code精度可能不太符合实际的需求，所以我提升到了128位的hash_bits. 测试代码和测试文本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> common.SimHash <span class="keyword">import</span> SimHashFilter</span><br><span class="line">text1 = <span class="string">"沉默螺旋模式中呈现出民意动力的来源在于人类有害怕孤立的弱点，但光害怕孤立不至于影响民意的形成，"</span> \</span><br><span class="line">    + <span class="string">"主要是当个人觉察到自己对某论题的意见与环境中的强势意见一致（或不一致时），害怕孤立这个变项才会产生作用。"</span> \</span><br><span class="line">    + <span class="string">"从心理学的范畴来看，社会中的强势意见越来越强，甚至比实际情形还强，弱势意见越来越弱，甚至比实际情形还弱，\</span></span><br><span class="line"><span class="string">这种动力运作的过程成–螺旋状"</span></span><br><span class="line"></span><br><span class="line">text2 = <span class="string">"沉默螺旋模式中呈现出民意动力的来源在于人类有害怕孤立的弱点，但光害怕孤立不至于影响民意的形成，"</span> \</span><br><span class="line">    + <span class="string">"从心理学的范畴来看，社会中的强势意见越来越强，甚至比实际情形还强，弱势意见越来越弱，甚至比实际情形还弱，\</span></span><br><span class="line"><span class="string">这种动力运作的过程成–螺旋状"</span> \</span><br><span class="line">+ <span class="string">"主要是当个人觉察到自己对某论题的意见与环境中的强势意见一致（或不一致时），害怕孤立这个变项才会产生作用。"</span></span><br><span class="line"></span><br><span class="line">filter = SimHashFilter(<span class="number">128</span>)</span><br><span class="line">print(bin(filter.GetCodeForText(text1)))</span><br><span class="line">print(bin(filter.GetCodeForText(text2)))</span><br><span class="line">print(filter.IsSimilarByText(text1, text2))</span><br></pre></td></tr></table></figure>
<pre><code>文本1: 
&quot;沉默螺旋模式中呈现出民意动力的来源在于人类有害怕孤立的弱点，但光害怕孤立不至于影响民意的形成，&quot;
+ &quot;主要是当个人觉察到自己对某论题的意见与环境中的强势意见一致（或不一致时），害怕孤立这个变项才会产生作用。&quot;
+ &quot;从心理学的范畴来看，社会中的强势意见越来越强，甚至比实际情形还强，弱势意见越来越弱，甚至比实际情形还弱，
这种动力运作的过程成–螺旋状&quot;

文本2:
&quot;沉默螺旋模式中呈现出民意动力的来源在于人类有害怕孤立的弱点，但光害怕孤立不至于影响民意的形成，&quot;
+ &quot;从心理学的范畴来看，社会中的强势意见越来越强，甚至比实际情形还强，弱势意见越来越弱，甚至比实际情形还弱，
这种动力运作的过程成–螺旋状&quot;
+ &quot;主要是当个人觉察到自己对某论题的意见与环境中的强势意见一致（或不一致时），害怕孤立这个变项才会产生作用。&quot;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行结果如下，可以看到生成的128位的hash code是完全相同的，上述的文本调换了语序生成的两段文本，相似度为1，所以这两段文本会被直接过滤掉其中一段文本。</p>
<div align="center">
<img src="/2019/07/16/data-processing/2.png">
</div>

<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在实际对后台数据库当中的数据运行该后处理模块时候，可以很明显的看到CSDN当中爬取到的博客文章被删掉了一半左右，因为真的很多转载的和抄袭的博客文章在其中，而对于<code>stackoverflow</code>这种大型的正规的QA网站，基本没有过滤掉很多是因为相似度超过阈值的这种文章，技术水平还是可以的，至少平时在看CSDN里的技术博客都会有这种感受，真的相似或者完全相同的文章太多了！！！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外需要提一点的就是simhash算法对于短文本的表现并不是很好，因为短文本进行分词之后，词语本身就很少，所以很大程度的影响了后面的hashing过程。不过在我们这次的项目当中都是内容比较多的文本，所以simhash算法的效果还是挺不错的 :）</p>
<hr>
<p><br></p>
<h4 id="摘要生成算法TextRank"><a href="#摘要生成算法TextRank" class="headerlink" title="摘要生成算法TextRank"></a>摘要生成算法TextRank</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>TextRank</code>是一种基于无向图的无监督算法，可以用来进行<code>关键字提取</code>与<code>文章摘要生成</code>等工作。TextRank算法的前身是Google为网页排序而提出的<code>PageRank</code>的算法。<a href="https://zh.wikipedia.org/wiki/PageRank" target="_blank" rel="noopener">PageRank</a>的主要思想也是基于图论的方法，用网页之间的链接来形成庞大的有向图，图中的边权重代表的是从用户从某个网页进入到另一个网页的概率，然后进行迭代更新，得到rank最大的那些网站显示。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>TextRank</code>的思想和<code>PageRank</code>很像，算法的主要流程由如下这几点组成：</p>
<ul>
<li>文本分割为句子</li>
<li>对分割出来的句子进行向量化,其中也包括了stopwords、词性的过滤步骤</li>
<li>确定不同句子之间是否存在边，这个利用的是类似滑动窗口的方法，在固定长度K的窗口当中，如果共同出现n个单词，我们就认为这两个句子之间存在边。一般情况下n取2.</li>
<li>计算不同句子之间的相似度，用句子之间的相似度充当无向图当中边的权重</li>
<li>构造相似度矩阵</li>
<li>构造无向图，其中节点是每一个分割出来的句子，每条边的权重是不同句子之间的相似度</li>
<li>迭代更新TextRank的值，直到最后无向图中节点的TextRank值收敛</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于每个句子节点的TextRank值的计算公式如下：</p>
<script type="math/tex; mode=display">
TR(V_i)=(1-d)+d*\sum_{V_j\in In(V_i)} \frac{\omega_{ji}}{\sum_{V_k \in Out(V_j)} \omega_{jk}} * TR(V_j)</script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中变量$d$表示的是阻尼系数，主要是为了避免有的节点和别的节点之间没有边而出现的<code>TextRank</code>值为0的情况。$\omega_{ik}$代表的就是$i, k$两个句子节点之间的权重值。之后只要根据更新公式进行迭代计算直至收敛即可，然后选取<code>TextRank</code>值最高的几个节点对应的句子，就能形成整篇文档的摘要，实现了自动摘要生成的功能。具体的流程如下所示：</p>
<div align="center">
<img src="/2019/07/16/data-processing/3.png">
</div>

<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不过稍微有些遗憾的是，我并没有在我们的项目当中再造轮子实现TextRank算法，要是时间能再长一点可以尝试着实现一波TextRank算法。在我们项目当中使用的是一个开源项目<a href="https://github.com/letiantian/TextRank4ZH" target="_blank" rel="noopener">textrank4zh</a>, 这个项目使用的自动摘要算法就是使用的TextRank的算法实现。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当然这种方法的速度比较慢，毕竟需要针对全文构建一张无向图，然后在无向图上进行迭代更新，所以实际运行的时候，很大一部分时间是花费在自动摘要生成上面，大概一篇文章2秒左右的生成时间，所以我们花了一晚上的时间对所有收集到的文章进行自动摘要。当然我们也不能保证TextRank就能生成最准确的摘要信息，所以以后有机会去调研其他的摘要生成、关键词生成的算法和研究。</p>
<hr>
<p><br></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这篇小论文当中，我主要是阐述了本次项目当中实际运用到的<code>simhash</code>和<code>textrank</code>两个算法。当然其实这两个算法都有一定的年头了，在实际的效果上比不上现在大热的NLP技术。不过这次项目能够让我在短时间内完成整个数据获取和数据清洗加工的过程，并且去了解相关的算法研究，我觉得还是有一定的价值和意义的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 之后如果有时间的话，可以对其他的相似度计算和摘要生成、关键字生成的算法进行调研、研究，相信对之后的科研生活有一定帮助的。</p>
<p><br></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://blog.csdn.net/wotui1842/article/details/80351386" target="_blank" rel="noopener">TextRank算法的基本原理及textrank4zh使用实例</a></li>
<li><a href="https://www.letiantian.me/2014-12-01-text-rank/" target="_blank" rel="noopener">使用TextRank算法为文本生成关键字和摘要</a></li>
<li><a href="https://www2007.org/papers/paper215.pdf" target="_blank" rel="noopener">Detecting Near-Duplicates for Web Crawling</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=509965" target="_blank" rel="noopener">Similarity estimation techniques from rounding algorithms</a></li>
<li><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.03.html" target="_blank" rel="noopener">simhash算法</a></li>
</ol>
]]></content>
      <categories>
        <category>data-processing</category>
      </categories>
      <tags>
        <tag>data-processing</tag>
      </tags>
  </entry>
</search>
